(*****************************************)
(*      This file is autogenerated       *)
(*   Any manual changes will be LOST!    *)
(*****************************************)
(* Generated 2001-01-12 15:04:05         *)
(*****************************************)
(* This file should be stored in the     *)
(* same directory as the form/datamodule *)
(* with the corresponding model          *)
(*****************************************)
(* Copyright notice:                     *)
(*                                       *)
(*****************************************)

unit ModelEvTemporal;

{$DEFINE ModelEvTemporal_unitheader}
{$INCLUDE ModelEvTemporal_Interface.inc}

uses
  {ImplementationUses}
  {ImplementationDependancies}
  BoldGeneratedCodeDictionary;

{ Includefile for methodimplementations }


const
  BoldMemberAssertSelfAssigned: string = 'Unable to access member %s.%s: Object is not assigned!)';
  BoldMemberAssertInvalidType: string = 'Invalid membertype for %s.%s. Expected %s (code might be out of sync with model)';
  BoldMemberAssertInvalidObjectType: string = 'Object of singlelink (%s.%s) is of wrong type (is %s, should be %s)';
  BoldMemberAssertInvalidDelphiName: string = '%s.%s: Member is incorrect. it is called %s in meta info (code might be out of sync with model)';

{ TTempRootClass }

function TTempRootClass._Get_M_RootAttr: TBAInteger;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TTempRootClass', 'RootAttr'] ));
  assert( BoldMembers[0] is TBAInteger, format( BoldMemberAssertInvalidType, [ClassName, 'RootAttr', 'TBAInteger'] ));
  assert( BoldMembers[0].BoldMemberRTInfo.DelphiName = 'RootAttr', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'RootAttr', BoldMembers[0].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[0] as TBAInteger;
end;

function TTempRootClass._GetRootAttr: Integer;
begin
  Result := M_RootAttr.AsInteger;
end;

procedure TTempRootClass._SetRootAttr(NewValue: Integer);
begin
  M_RootAttr.AsInteger := NewValue;
end;


procedure TTempRootClassList.Add(NewObject: TTempRootClass);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TTempRootClassList.IndexOf(anObject: TTempRootClass): Integer;
begin
  result := IndexOfElement( anObject );
end;

function TTempRootClassList.Includes( anObject: TTempRootClass ) : Boolean;
begin
  result := IncludesElement( anObject );
end;

procedure TTempRootClassList.Insert(index: Integer; NewObject: TTempRootClass);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TTempRootClassList.GetBoldObject(index: Integer): TTempRootClass;
begin
  result := GetElement(index) as TTempRootClass;
end;

procedure TTempRootClassList.SetBoldObject(index: Integer; NewObject: TTempRootClass);
begin;
  SetElement( index, NewObject );
end;


{ TTempA }

function TTempA._Get_M_A1: TBAString;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TTempA', 'A1'] ));
  assert( BoldMembers[1] is TBAString, format( BoldMemberAssertInvalidType, [ClassName, 'A1', 'TBAString'] ));
  assert( BoldMembers[1].BoldMemberRTInfo.DelphiName = 'A1', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'A1', BoldMembers[1].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[1] as TBAString;
end;

function TTempA._GetA1: String;
begin
  Result := M_A1.AsString;
end;

procedure TTempA._SetA1(NewValue: String);
begin
  M_A1.AsString := NewValue;
end;

function TTempA._Get_M_a2: TBAInteger;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TTempA', 'a2'] ));
  assert( BoldMembers[2] is TBAInteger, format( BoldMemberAssertInvalidType, [ClassName, 'a2', 'TBAInteger'] ));
  assert( BoldMembers[2].BoldMemberRTInfo.DelphiName = 'a2', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'a2', BoldMembers[2].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[2] as TBAInteger;
end;

function TTempA._Geta2: Integer;
begin
  Result := M_a2.AsInteger;
end;

procedure TTempA._Seta2(NewValue: Integer);
begin
  M_a2.AsInteger := NewValue;
end;

function TTempA._Get_M_a3: TBAString;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TTempA', 'a3'] ));
  assert( BoldMembers[3] is TBAString, format( BoldMemberAssertInvalidType, [ClassName, 'a3', 'TBAString'] ));
  assert( BoldMembers[3].BoldMemberRTInfo.DelphiName = 'a3', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'a3', BoldMembers[3].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[3] as TBAString;
end;

function TTempA._Geta3: String;
begin
  Result := M_a3.AsString;
end;

procedure TTempA._Seta3(NewValue: String);
begin
  M_a3.AsString := NewValue;
end;


procedure TTempAList.Add(NewObject: TTempA);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TTempAList.IndexOf(anObject: TTempA): Integer;
begin
  result := IndexOfElement( anObject );
end;

function TTempAList.Includes( anObject: TTempA ) : Boolean;
begin
  result := IncludesElement( anObject );
end;

procedure TTempAList.Insert(index: Integer; NewObject: TTempA);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TTempAList.GetBoldObject(index: Integer): TTempA;
begin
  result := GetElement(index) as TTempA;
end;

procedure TTempAList.SetBoldObject(index: Integer; NewObject: TTempA);
begin;
  SetElement( index, NewObject );
end;


{ TTempB }

function TTempB._Get_M_b1: TBAString;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TTempB', 'b1'] ));
  assert( BoldMembers[4] is TBAString, format( BoldMemberAssertInvalidType, [ClassName, 'b1', 'TBAString'] ));
  assert( BoldMembers[4].BoldMemberRTInfo.DelphiName = 'b1', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'b1', BoldMembers[4].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[4] as TBAString;
end;

function TTempB._Getb1: String;
begin
  Result := M_b1.AsString;
end;

procedure TTempB._Setb1(NewValue: String);
begin
  M_b1.AsString := NewValue;
end;


procedure TTempBList.Add(NewObject: TTempB);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TTempBList.IndexOf(anObject: TTempB): Integer;
begin
  result := IndexOfElement( anObject );
end;

function TTempBList.Includes( anObject: TTempB ) : Boolean;
begin
  result := IncludesElement( anObject );
end;

procedure TTempBList.Insert(index: Integer; NewObject: TTempB);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TTempBList.GetBoldObject(index: Integer): TTempB;
begin
  result := GetElement(index) as TTempB;
end;

procedure TTempBList.SetBoldObject(index: Integer; NewObject: TTempB);
begin;
  SetElement( index, NewObject );
end;


{ TTempUnversioned }

function TTempUnversioned._Get_M_u1: TBAString;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TTempUnversioned', 'u1'] ));
  assert( BoldMembers[4] is TBAString, format( BoldMemberAssertInvalidType, [ClassName, 'u1', 'TBAString'] ));
  assert( BoldMembers[4].BoldMemberRTInfo.DelphiName = 'u1', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'u1', BoldMembers[4].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[4] as TBAString;
end;

function TTempUnversioned._Getu1: String;
begin
  Result := M_u1.AsString;
end;

procedure TTempUnversioned._Setu1(NewValue: String);
begin
  M_u1.AsString := NewValue;
end;

function TTempUnversioned._Get_M_u2: TBAInteger;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TTempUnversioned', 'u2'] ));
  assert( BoldMembers[5] is TBAInteger, format( BoldMemberAssertInvalidType, [ClassName, 'u2', 'TBAInteger'] ));
  assert( BoldMembers[5].BoldMemberRTInfo.DelphiName = 'u2', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'u2', BoldMembers[5].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[5] as TBAInteger;
end;

function TTempUnversioned._Getu2: Integer;
begin
  Result := M_u2.AsInteger;
end;

procedure TTempUnversioned._Setu2(NewValue: Integer);
begin
  M_u2.AsInteger := NewValue;
end;


procedure TTempUnversionedList.Add(NewObject: TTempUnversioned);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TTempUnversionedList.IndexOf(anObject: TTempUnversioned): Integer;
begin
  result := IndexOfElement( anObject );
end;

function TTempUnversionedList.Includes( anObject: TTempUnversioned ) : Boolean;
begin
  result := IncludesElement( anObject );
end;

procedure TTempUnversionedList.Insert(index: Integer; NewObject: TTempUnversioned);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TTempUnversionedList.GetBoldObject(index: Integer): TTempUnversioned;
begin
  result := GetElement(index) as TTempUnversioned;
end;

procedure TTempUnversionedList.SetBoldObject(index: Integer; NewObject: TTempUnversioned);
begin;
  SetElement( index, NewObject );
end;



function GeneratedCodeCRC: integer;
begin
  result := 0;
end;

procedure InstallObjectListClasses(BoldObjectListClasses: TBoldGeneratedClassList);
begin
  BoldObjectListClasses.AddObjectEntry('TempRootClass', TTempRootClassList);
  BoldObjectListClasses.AddObjectEntry('TempA', TTempAList);
  BoldObjectListClasses.AddObjectEntry('TempB', TTempBList);
  BoldObjectListClasses.AddObjectEntry('TempUnversioned', TTempUnversionedList);
end;

procedure InstallBusinessClasses(BoldObjectClasses: TBoldGeneratedClassList);
begin
  BoldObjectClasses.AddObjectEntry('TempRootClass', TTempRootClass);
  BoldObjectClasses.AddObjectEntry('TempA', TTempA);
  BoldObjectClasses.AddObjectEntry('TempB', TTempB);
  BoldObjectClasses.AddObjectEntry('TempUnversioned', TTempUnversioned);
end;

var
  CodeDescriptor: TBoldGeneratedCodeDescriptor;

initialization
  CodeDescriptor := GeneratedCodes.AddGeneratedCodeDescriptorWithFunc( 'ModelEvTemporal', InstallBusinessClasses, InstallObjectListClasses );
finalization
  GeneratedCodes.Remove(CodeDescriptor);
end.



 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
