(*****************************************)
(*      This file is autogenerated       *)
(*   Any manual changes will be LOST!    *)
(*****************************************)
(* Generated 2001-01-18 15:30:35         *)
(*****************************************)
(* This file should be stored in the     *)
(* same directory as the form/datamodule *)
(* with the corresponding model          *)
(*****************************************)
(* Copyright notice:                     *)
(*                                       *)
(*****************************************)

unit ModEv_Upgrade;

{$DEFINE ModEv_Upgrade_unitheader}
{$INCLUDE ModEv_Upgrade_Interface.inc}

uses
  {ImplementationUses}
  {ImplementationDependancies}
  BoldGeneratedCodeDictionary;

{ Includefile for methodimplementations }


const
  BoldMemberAssertSelfAssigned: string = 'Unable to access member %s.%s: Object is not assigned!)';
  BoldMemberAssertInvalidType: string = 'Invalid membertype for %s.%s. Expected %s (code might be out of sync with model)';
  BoldMemberAssertInvalidObjectType: string = 'Object of singlelink (%s.%s) is of wrong type (is %s, should be %s)';
  BoldMemberAssertInvalidDelphiName: string = '%s.%s: Member is incorrect. it is called %s in meta info (code might be out of sync with model)';

{ TBusinessClassesRoot }


procedure TBusinessClassesRootList.Add(NewObject: TBusinessClassesRoot);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TBusinessClassesRootList.IndexOf(anObject: TBusinessClassesRoot): Integer;
begin
  result := IndexOfElement( anObject );
end;

function TBusinessClassesRootList.Includes( anObject: TBusinessClassesRoot ) : Boolean;
begin
  result := IncludesElement( anObject );
end;

procedure TBusinessClassesRootList.Insert(index: Integer; NewObject: TBusinessClassesRoot);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TBusinessClassesRootList.GetBoldObject(index: Integer): TBusinessClassesRoot;
begin
  result := GetElement(index) as TBusinessClassesRoot;
end;

procedure TBusinessClassesRootList.SetBoldObject(index: Integer; NewObject: TBusinessClassesRoot);
begin;
  SetElement( index, NewObject );
end;


{ TUpA }

function TUpA._Get_M_Name: TBAInteger;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TUpA', 'Name'] ));
  assert( BoldMembers[0] is TBAInteger, format( BoldMemberAssertInvalidType, [ClassName, 'Name', 'TBAInteger'] ));
  assert( BoldMembers[0].BoldMemberRTInfo.DelphiName = 'Name', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'Name', BoldMembers[0].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[0] as TBAInteger;
end;

function TUpA._GetName: Integer;
begin
  Result := M_Name.AsInteger;
end;

procedure TUpA._SetName(NewValue: Integer);
begin
  M_Name.AsInteger := NewValue;
end;

function TUpA._Get_M_NewName: TBAString;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TUpA', 'NewName'] ));
  assert( BoldMembers[1] is TBAString, format( BoldMemberAssertInvalidType, [ClassName, 'NewName', 'TBAString'] ));
  assert( BoldMembers[1].BoldMemberRTInfo.DelphiName = 'NewName', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'NewName', BoldMembers[1].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[1] as TBAString;
end;

function TUpA._GetNewName: String;
begin
  Result := M_NewName.AsString;
end;

procedure TUpA._SetNewName(NewValue: String);
begin
  M_NewName.AsString := NewValue;
end;


procedure TUpAList.Add(NewObject: TUpA);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TUpAList.IndexOf(anObject: TUpA): Integer;
begin
  result := IndexOfElement( anObject );
end;

function TUpAList.Includes( anObject: TUpA ) : Boolean;
begin
  result := IncludesElement( anObject );
end;

procedure TUpAList.Insert(index: Integer; NewObject: TUpA);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TUpAList.GetBoldObject(index: Integer): TUpA;
begin
  result := GetElement(index) as TUpA;
end;

procedure TUpAList.SetBoldObject(index: Integer; NewObject: TUpA);
begin;
  SetElement( index, NewObject );
end;


{ TUpB }

function TUpB._Get_M_Amount: TBACurrency;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TUpB', 'Amount'] ));
  assert( BoldMembers[0] is TBACurrency, format( BoldMemberAssertInvalidType, [ClassName, 'Amount', 'TBACurrency'] ));
  assert( BoldMembers[0].BoldMemberRTInfo.DelphiName = 'Amount', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'Amount', BoldMembers[0].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[0] as TBACurrency;
end;

function TUpB._GetAmount: Currency;
begin
  Result := M_Amount.AsCurrency;
end;

procedure TUpB._SetAmount(NewValue: Currency);
begin
  M_Amount.AsCurrency := NewValue;
end;

function TUpB._Get_M_EuroAmount: TBACurrency;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TUpB', 'EuroAmount'] ));
  assert( BoldMembers[1] is TBACurrency, format( BoldMemberAssertInvalidType, [ClassName, 'EuroAmount', 'TBACurrency'] ));
  assert( BoldMembers[1].BoldMemberRTInfo.DelphiName = 'EuroAmount', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'EuroAmount', BoldMembers[1].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[1] as TBACurrency;
end;

function TUpB._GetEuroAmount: Currency;
begin
  Result := M_EuroAmount.AsCurrency;
end;

procedure TUpB._SetEuroAmount(NewValue: Currency);
begin
  M_EuroAmount.AsCurrency := NewValue;
end;


procedure TUpBList.Add(NewObject: TUpB);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TUpBList.IndexOf(anObject: TUpB): Integer;
begin
  result := IndexOfElement( anObject );
end;

function TUpBList.Includes( anObject: TUpB ) : Boolean;
begin
  result := IncludesElement( anObject );
end;

procedure TUpBList.Insert(index: Integer; NewObject: TUpB);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TUpBList.GetBoldObject(index: Integer): TUpB;
begin
  result := GetElement(index) as TUpB;
end;

procedure TUpBList.SetBoldObject(index: Integer; NewObject: TUpB);
begin;
  SetElement( index, NewObject );
end;


{ TUpC }

function TUpC._Get_M_name: TBAString;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TUpC', 'name'] ));
  assert( BoldMembers[0] is TBAString, format( BoldMemberAssertInvalidType, [ClassName, 'name', 'TBAString'] ));
  assert( BoldMembers[0].BoldMemberRTInfo.DelphiName = 'name', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'name', BoldMembers[0].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[0] as TBAString;
end;

function TUpC._Getname: String;
begin
  Result := M_name.AsString;
end;

procedure TUpC._Setname(NewValue: String);
begin
  M_name.AsString := NewValue;
end;

function TUpC._Get_M_UpD: TBoldObjectReference;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TUpC', 'UpD'] ));
  assert( BoldMembers[1] is TBoldObjectReference, format( BoldMemberAssertInvalidType, [ClassName, 'UpD', 'TBoldObjectReference'] ));
  assert( BoldMembers[1].BoldMemberRTInfo.DelphiName = 'UpD', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'UpD', BoldMembers[1].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[1] as TBoldObjectReference;
end;

function TUpC._GetUpD: TUpD;
begin
  assert( not assigned(M_UpD.BoldObject ) or (M_UpD.BoldObject is TUpD), format( BoldMemberAssertInvalidObjectType, [ClassName, UpD, M_UpD.BoldObject.ClassName, TUpD]));
  Result := M_UpD.BoldObject as TUpD;
end;

procedure TUpC._SetUpD(value: TUpD);
begin
  M_UpD.BoldObject := value;
end;


procedure TUpCList.Add(NewObject: TUpC);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TUpCList.IndexOf(anObject: TUpC): Integer;
begin
  result := IndexOfElement( anObject );
end;

function TUpCList.Includes( anObject: TUpC ) : Boolean;
begin
  result := IncludesElement( anObject );
end;

procedure TUpCList.Insert(index: Integer; NewObject: TUpC);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TUpCList.GetBoldObject(index: Integer): TUpC;
begin
  result := GetElement(index) as TUpC;
end;

procedure TUpCList.SetBoldObject(index: Integer; NewObject: TUpC);
begin;
  SetElement( index, NewObject );
end;


{ TUpD }

function TUpD._Get_M_anAttr: TBAString;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TUpD', 'anAttr'] ));
  assert( BoldMembers[0] is TBAString, format( BoldMemberAssertInvalidType, [ClassName, 'anAttr', 'TBAString'] ));
  assert( BoldMembers[0].BoldMemberRTInfo.DelphiName = 'anAttr', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'anAttr', BoldMembers[0].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[0] as TBAString;
end;

function TUpD._GetanAttr: String;
begin
  Result := M_anAttr.AsString;
end;

procedure TUpD._SetanAttr(NewValue: String);
begin
  M_anAttr.AsString := NewValue;
end;



procedure TUpDList.Add(NewObject: TUpD);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TUpDList.IndexOf(anObject: TUpD): Integer;
begin
  result := IndexOfElement( anObject );
end;

function TUpDList.Includes( anObject: TUpD ) : Boolean;
begin
  result := IncludesElement( anObject );
end;

procedure TUpDList.Insert(index: Integer; NewObject: TUpD);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TUpDList.GetBoldObject(index: Integer): TUpD;
begin
  result := GetElement(index) as TUpD;
end;

procedure TUpDList.SetBoldObject(index: Integer; NewObject: TUpD);
begin;
  SetElement( index, NewObject );
end;



function GeneratedCodeCRC: integer;
begin
  result := 0;
end;

procedure InstallObjectListClasses(BoldObjectListClasses: TBoldGeneratedClassList);
begin
  BoldObjectListClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRootList);
  BoldObjectListClasses.AddObjectEntry('UpA', TUpAList);
  BoldObjectListClasses.AddObjectEntry('UpB', TUpBList);
  BoldObjectListClasses.AddObjectEntry('UpC', TUpCList);
  BoldObjectListClasses.AddObjectEntry('UpD', TUpDList);
end;

procedure InstallBusinessClasses(BoldObjectClasses: TBoldGeneratedClassList);
begin
  BoldObjectClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRoot);
  BoldObjectClasses.AddObjectEntry('UpA', TUpA);
  BoldObjectClasses.AddObjectEntry('UpB', TUpB);
  BoldObjectClasses.AddObjectEntry('UpC', TUpC);
  BoldObjectClasses.AddObjectEntry('UpD', TUpD);
end;

var
  CodeDescriptor: TBoldGeneratedCodeDescriptor;

initialization
  CodeDescriptor := GeneratedCodes.AddGeneratedCodeDescriptorWithFunc( 'ModEv_Upgrade', InstallBusinessClasses, InstallObjectListClasses );
finalization
  GeneratedCodes.Remove(CodeDescriptor);
end.



 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
