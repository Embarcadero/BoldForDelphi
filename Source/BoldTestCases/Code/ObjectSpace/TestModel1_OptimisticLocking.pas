(*****************************************)
(*      This file is autogenerated       *)
(*   Any manual changes will be LOST!    *)
(*****************************************)
(* Generated 11-06-2019 19:48:12         *)
(*****************************************)
(* This file should be stored in the     *)
(* same directory as the form/datamodule *)
(* with the corresponding model          *)
(*****************************************)
(* Copyright notice:                     *)
(*                                       *)
(*****************************************)

unit TestModel1_OptimisticLocking;

{$DEFINE TestModel1_OptimisticLocking_unitheader}
{$INCLUDE TestModel1_OptimisticLocking_Interface.inc}

{ Includefile for methodimplementations }


const
  BoldMemberAssertInvalidObjectType: string = 'Object of singlelink (%s.%s) is of wrong type (is %s, should be %s)';

{ TBusinessClassesRoot }

procedure TBusinessClassesRootList.Add(NewObject: TBusinessClassesRoot);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TBusinessClassesRootList.IndexOf(anObject: TBusinessClassesRoot): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TBusinessClassesRootList.Includes(anObject: TBusinessClassesRoot) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TBusinessClassesRootList.AddNew: TBusinessClassesRoot;
begin
  result := TBusinessClassesRoot(InternalAddNew);
end;

procedure TBusinessClassesRootList.Insert(index: Integer; NewObject: TBusinessClassesRoot);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TBusinessClassesRootList.GetBoldObject(index: Integer): TBusinessClassesRoot;
begin
  result := TBusinessClassesRoot(GetElement(index));
end;

procedure TBusinessClassesRootList.SetBoldObject(index: Integer; NewObject: TBusinessClassesRoot);
begin;
  SetElement(index, NewObject);
end;

{$IFDEF UseBoldListEnumerator}
function TBusinessClassesRootList.GetEnumerator: TBusinessClassesRootListEnumerator;
begin
 Result := TBusinessClassesRootListEnumerator.Create(Self);
end;

function TBusinessClassesRootListEnumerator.GetCurrent: TBusinessClassesRoot;
begin
 Result := List[Index] as TBusinessClassesRoot;
end;

{$ENDIF UseBoldListEnumerator}

{ TClassA }

function TClassA._Get_M_aString: TBAString;
begin
  assert(ValidateMember('TClassA', 'aString', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TClassA._GetaString: String;
begin
  Result := M_aString.AsString;
end;

procedure TClassA._SetaString(const NewValue: String);
begin
  M_aString.AsString := NewValue;
end;

function TClassA._Get_M_aBoolean: TBABoolean;
begin
  assert(ValidateMember('TClassA', 'aBoolean', 1, TBABoolean));
  Result := TBABoolean(BoldMembers[1]);
end;

function TClassA._GetaBoolean: Boolean;
begin
  Result := M_aBoolean.AsBoolean;
end;

procedure TClassA._SetaBoolean(const NewValue: Boolean);
begin
  M_aBoolean.AsBoolean := NewValue;
end;

function TClassA._Get_M_aByte: TBAByte;
begin
  assert(ValidateMember('TClassA', 'aByte', 2, TBAByte));
  Result := TBAByte(BoldMembers[2]);
end;

function TClassA._GetaByte: Byte;
begin
  Result := M_aByte.AsByte;
end;

procedure TClassA._SetaByte(const NewValue: Byte);
begin
  M_aByte.AsByte := NewValue;
end;

function TClassA._Get_M_aCurrency: TBACurrency;
begin
  assert(ValidateMember('TClassA', 'aCurrency', 3, TBACurrency));
  Result := TBACurrency(BoldMembers[3]);
end;

function TClassA._GetaCurrency: Currency;
begin
  Result := M_aCurrency.AsCurrency;
end;

procedure TClassA._SetaCurrency(const NewValue: Currency);
begin
  M_aCurrency.AsCurrency := NewValue;
end;

function TClassA._Get_M_aDate: TBADate;
begin
  assert(ValidateMember('TClassA', 'aDate', 4, TBADate));
  Result := TBADate(BoldMembers[4]);
end;

function TClassA._GetaDate: TDate;
begin
  Result := M_aDate.AsDate;
end;

procedure TClassA._SetaDate(const NewValue: TDate);
begin
  M_aDate.AsDate := NewValue;
end;

function TClassA._Get_M_aDateTime: TBADateTime;
begin
  assert(ValidateMember('TClassA', 'aDateTime', 5, TBADateTime));
  Result := TBADateTime(BoldMembers[5]);
end;

function TClassA._GetaDateTime: TDateTime;
begin
  Result := M_aDateTime.AsDateTime;
end;

procedure TClassA._SetaDateTime(const NewValue: TDateTime);
begin
  M_aDateTime.AsDateTime := NewValue;
end;

function TClassA._Get_M_aFloat: TBAFloat;
begin
  assert(ValidateMember('TClassA', 'aFloat', 6, TBAFloat));
  Result := TBAFloat(BoldMembers[6]);
end;

function TClassA._GetaFloat: double;
begin
  Result := M_aFloat.AsFloat;
end;

procedure TClassA._SetaFloat(const NewValue: double);
begin
  M_aFloat.AsFloat := NewValue;
end;

function TClassA._Get_M_aInteger: TBAInteger;
begin
  assert(ValidateMember('TClassA', 'aInteger', 7, TBAInteger));
  Result := TBAInteger(BoldMembers[7]);
end;

function TClassA._GetaInteger: Integer;
begin
  Result := M_aInteger.AsInteger;
end;

procedure TClassA._SetaInteger(const NewValue: Integer);
begin
  M_aInteger.AsInteger := NewValue;
end;

function TClassA._Get_M_aShortInt: TBAShortInt;
begin
  assert(ValidateMember('TClassA', 'aShortInt', 8, TBAShortInt));
  Result := TBAShortInt(BoldMembers[8]);
end;

function TClassA._GetaShortInt: ShortInt;
begin
  Result := M_aShortInt.AsShortInt;
end;

procedure TClassA._SetaShortInt(const NewValue: ShortInt);
begin
  M_aShortInt.AsShortInt := NewValue;
end;

function TClassA._Get_M_aSmallInt: TBASmallInt;
begin
  assert(ValidateMember('TClassA', 'aSmallInt', 9, TBASmallInt));
  Result := TBASmallInt(BoldMembers[9]);
end;

function TClassA._GetaSmallInt: SmallInt;
begin
  Result := M_aSmallInt.AsSmallInt;
end;

procedure TClassA._SetaSmallInt(const NewValue: SmallInt);
begin
  M_aSmallInt.AsSmallInt := NewValue;
end;

function TClassA._Get_M_aTime: TBATime;
begin
  assert(ValidateMember('TClassA', 'aTime', 10, TBATime));
  Result := TBATime(BoldMembers[10]);
end;

function TClassA._GetaTime: TTime;
begin
  Result := M_aTime.AsTime;
end;

procedure TClassA._SetaTime(const NewValue: TTime);
begin
  M_aTime.AsTime := NewValue;
end;

function TClassA._Get_M_aWord: TBAWord;
begin
  assert(ValidateMember('TClassA', 'aWord', 11, TBAWord));
  Result := TBAWord(BoldMembers[11]);
end;

function TClassA._GetaWord: Word;
begin
  Result := M_aWord.AsWord;
end;

procedure TClassA._SetaWord(const NewValue: Word);
begin
  M_aWord.AsWord := NewValue;
end;

function TClassA._Get_M_aBlob: TBABlob;
begin
  assert(ValidateMember('TClassA', 'aBlob', 12, TBABlob));
  Result := TBABlob(BoldMembers[12]);
end;

function TClassA._GetaBlob: String;
begin
  Result := M_aBlob.AsString;
end;

procedure TClassA._SetaBlob(const NewValue: String);
begin
  M_aBlob.AsString := NewValue;
end;

function TClassA._Get_M_aBlobContent: TBATypedBlob;
begin
  assert(ValidateMember('TClassA', 'aBlobContent', 13, TBATypedBlob));
  Result := TBATypedBlob(BoldMembers[13]);
end;

function TClassA._GetaBlobContent: String;
begin
  Result := M_aBlobContent.AsString;
end;

procedure TClassA._SetaBlobContent(const NewValue: String);
begin
  M_aBlobContent.AsString := NewValue;
end;

function TClassA._Getpart: TClassAList;
begin
  assert(ValidateMember('TClassA', 'part', 14, TClassAList));
  Result := TClassAList(BoldMembers[14]);
end;

function TClassA._Getpartpartpartof: partpartofList;
begin
  assert(ValidateMember('TClassA', 'partpartpartof', 15, partpartofList));
  Result := partpartofList(BoldMembers[15]);
end;

function TClassA._Getpartof: TClassAList;
begin
  assert(ValidateMember('TClassA', 'partof', 16, TClassAList));
  Result := TClassAList(BoldMembers[16]);
end;

function TClassA._Getpartofpartpartof: partpartofList;
begin
  assert(ValidateMember('TClassA', 'partofpartpartof', 17, partpartofList));
  Result := partpartofList(BoldMembers[17]);
end;

function TClassA._Getchild: TClassAList;
begin
  assert(ValidateMember('TClassA', 'child', 18, TClassAList));
  Result := TClassAList(BoldMembers[18]);
end;

function TClassA._Get_M_parent: TBoldObjectReference;
begin
  assert(ValidateMember('TClassA', 'parent', 19, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[19]);
end;

function TClassA._Getparent: TClassA;
begin
  Result := TClassA(M_parent.BoldObject);
  assert(not assigned(Result) or (Result is TClassA), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'parent', Result.ClassName, 'TClassA']));
end;

procedure TClassA._Setparent(const value: TClassA);
begin
  M_parent.BoldObject := value;
end;

function TClassA._Get_M_next: TBoldObjectReference;
begin
  assert(ValidateMember('TClassA', 'next', 20, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[20]);
end;

function TClassA._Getnext: TClassA;
begin
  Result := TClassA(M_next.BoldObject);
  assert(not assigned(Result) or (Result is TClassA), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'next', Result.ClassName, 'TClassA']));
end;

procedure TClassA._Setnext(const value: TClassA);
begin
  M_next.BoldObject := value;
end;

function TClassA._Get_M_previous: TBoldObjectReference;
begin
  assert(ValidateMember('TClassA', 'previous', 21, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[21]);
end;

function TClassA._Getprevious: TClassA;
begin
  Result := TClassA(M_previous.BoldObject);
  assert(not assigned(Result) or (Result is TClassA), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'previous', Result.ClassName, 'TClassA']));
end;

procedure TClassA._Setprevious(const value: TClassA);
begin
  M_previous.BoldObject := value;
end;

procedure TClassAList.Add(NewObject: TClassA);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TClassAList.IndexOf(anObject: TClassA): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TClassAList.Includes(anObject: TClassA) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TClassAList.AddNew: TClassA;
begin
  result := TClassA(InternalAddNew);
end;

procedure TClassAList.Insert(index: Integer; NewObject: TClassA);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TClassAList.GetBoldObject(index: Integer): TClassA;
begin
  result := TClassA(GetElement(index));
end;

procedure TClassAList.SetBoldObject(index: Integer; NewObject: TClassA);
begin;
  SetElement(index, NewObject);
end;

{$IFDEF UseBoldListEnumerator}
function TClassAList.GetEnumerator: TClassAListEnumerator;
begin
 Result := TClassAListEnumerator.Create(Self);
end;

function TClassAListEnumerator.GetCurrent: TClassA;
begin
 Result := List[Index] as TClassA;
end;

{$ENDIF UseBoldListEnumerator}

{ TDocument }

function TDocument._Get_M_Title: TBAString;
begin
  assert(ValidateMember('TDocument', 'Title', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TDocument._GetTitle: String;
begin
  Result := M_Title.AsString;
end;

procedure TDocument._SetTitle(const NewValue: String);
begin
  M_Title.AsString := NewValue;
end;

function TDocument._Get_M_text: TBAString;
begin
  assert(ValidateMember('TDocument', 'text', 1, TBAString));
  Result := TBAString(BoldMembers[1]);
end;

function TDocument._Gettext: String;
begin
  Result := M_text.AsString;
end;

procedure TDocument._Settext(const NewValue: String);
begin
  M_text.AsString := NewValue;
end;

function TDocument._GetParts: TDocumentList;
begin
  assert(ValidateMember('TDocument', 'Parts', 2, TDocumentList));
  Result := TDocumentList(BoldMembers[2]);
end;

function TDocument._Get_M_PartOf: TBoldObjectReference;
begin
  assert(ValidateMember('TDocument', 'PartOf', 3, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[3]);
end;

function TDocument._GetPartOf: TDocument;
begin
  Result := TDocument(M_PartOf.BoldObject);
  assert(not assigned(Result) or (Result is TDocument), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'PartOf', Result.ClassName, 'TDocument']));
end;

procedure TDocument._SetPartOf(const value: TDocument);
begin
  M_PartOf.BoldObject := value;
end;

procedure TDocumentList.Add(NewObject: TDocument);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TDocumentList.IndexOf(anObject: TDocument): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TDocumentList.Includes(anObject: TDocument) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TDocumentList.AddNew: TDocument;
begin
  result := TDocument(InternalAddNew);
end;

procedure TDocumentList.Insert(index: Integer; NewObject: TDocument);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TDocumentList.GetBoldObject(index: Integer): TDocument;
begin
  result := TDocument(GetElement(index));
end;

procedure TDocumentList.SetBoldObject(index: Integer; NewObject: TDocument);
begin;
  SetElement(index, NewObject);
end;

{$IFDEF UseBoldListEnumerator}
function TDocumentList.GetEnumerator: TDocumentListEnumerator;
begin
 Result := TDocumentListEnumerator.Create(Self);
end;

function TDocumentListEnumerator.GetCurrent: TDocument;
begin
 Result := List[Index] as TDocument;
end;

{$ENDIF UseBoldListEnumerator}

{ THitList }

function THitList._Get_M_Name: TBAString;
begin
  assert(ValidateMember('THitList', 'Name', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function THitList._GetName: String;
begin
  Result := M_Name.AsString;
end;

procedure THitList._SetName(const NewValue: String);
begin
  M_Name.AsString := NewValue;
end;

function THitList._GetSong: TSongList;
begin
  assert(ValidateMember('THitList', 'Song', 1, TSongList));
  Result := TSongList(BoldMembers[1]);
end;

function THitList._GethitListsong: ThitListsongList;
begin
  assert(ValidateMember('THitList', 'hitListsong', 2, ThitListsongList));
  Result := ThitListsongList(BoldMembers[2]);
end;

procedure THitListList.Add(NewObject: THitList);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function THitListList.IndexOf(anObject: THitList): Integer;
begin
  result := IndexOfElement(anObject);
end;

function THitListList.Includes(anObject: THitList) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function THitListList.AddNew: THitList;
begin
  result := THitList(InternalAddNew);
end;

procedure THitListList.Insert(index: Integer; NewObject: THitList);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function THitListList.GetBoldObject(index: Integer): THitList;
begin
  result := THitList(GetElement(index));
end;

procedure THitListList.SetBoldObject(index: Integer; NewObject: THitList);
begin;
  SetElement(index, NewObject);
end;

{$IFDEF UseBoldListEnumerator}
function THitListList.GetEnumerator: THitListListEnumerator;
begin
 Result := THitListListEnumerator.Create(Self);
end;

function THitListListEnumerator.GetCurrent: THitList;
begin
 Result := List[Index] as THitList;
end;

{$ENDIF UseBoldListEnumerator}

{ TLinkClass }

function TLinkClass._Get_M_many: TBoldObjectReference;
begin
  assert(ValidateMember('TLinkClass', 'many', 0, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[0]);
end;

function TLinkClass._Getmany: TThing;
begin
  Result := TThing(M_many.BoldObject);
  assert(not assigned(Result) or (Result is TThing), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'many', Result.ClassName, 'TThing']));
end;

function TLinkClass._Get_M_one: TBoldObjectReference;
begin
  assert(ValidateMember('TLinkClass', 'one', 1, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[1]);
end;

function TLinkClass._Getone: TThing;
begin
  Result := TThing(M_one.BoldObject);
  assert(not assigned(Result) or (Result is TThing), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'one', Result.ClassName, 'TThing']));
end;

procedure TLinkClassList.Add(NewObject: TLinkClass);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TLinkClassList.IndexOf(anObject: TLinkClass): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TLinkClassList.Includes(anObject: TLinkClass) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TLinkClassList.AddNew: TLinkClass;
begin
  result := TLinkClass(InternalAddNew);
end;

procedure TLinkClassList.Insert(index: Integer; NewObject: TLinkClass);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TLinkClassList.GetBoldObject(index: Integer): TLinkClass;
begin
  result := TLinkClass(GetElement(index));
end;

procedure TLinkClassList.SetBoldObject(index: Integer; NewObject: TLinkClass);
begin;
  SetElement(index, NewObject);
end;

{$IFDEF UseBoldListEnumerator}
function TLinkClassList.GetEnumerator: TLinkClassListEnumerator;
begin
 Result := TLinkClassListEnumerator.Create(Self);
end;

function TLinkClassListEnumerator.GetCurrent: TLinkClass;
begin
 Result := List[Index] as TLinkClass;
end;

{$ENDIF UseBoldListEnumerator}

{ TSong }

function TSong._Get_M_Title: TBAString;
begin
  assert(ValidateMember('TSong', 'Title', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TSong._GetTitle: String;
begin
  Result := M_Title.AsString;
end;

procedure TSong._SetTitle(const NewValue: String);
begin
  M_Title.AsString := NewValue;
end;

function TSong._GetHitList: THitListList;
begin
  assert(ValidateMember('TSong', 'HitList', 1, THitListList));
  Result := THitListList(BoldMembers[1]);
end;

function TSong._GethitListsong: ThitListsongList;
begin
  assert(ValidateMember('TSong', 'hitListsong', 2, ThitListsongList));
  Result := ThitListsongList(BoldMembers[2]);
end;

procedure TSongList.Add(NewObject: TSong);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TSongList.IndexOf(anObject: TSong): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TSongList.Includes(anObject: TSong) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TSongList.AddNew: TSong;
begin
  result := TSong(InternalAddNew);
end;

procedure TSongList.Insert(index: Integer; NewObject: TSong);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TSongList.GetBoldObject(index: Integer): TSong;
begin
  result := TSong(GetElement(index));
end;

procedure TSongList.SetBoldObject(index: Integer; NewObject: TSong);
begin;
  SetElement(index, NewObject);
end;

{$IFDEF UseBoldListEnumerator}
function TSongList.GetEnumerator: TSongListEnumerator;
begin
 Result := TSongListEnumerator.Create(Self);
end;

function TSongListEnumerator.GetCurrent: TSong;
begin
 Result := List[Index] as TSong;
end;

{$ENDIF UseBoldListEnumerator}

{ TThing }

function TThing._Get_M_aTransient: TBAString;
begin
  assert(ValidateMember('TThing', 'aTransient', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TThing._GetaTransient: String;
begin
  Result := M_aTransient.AsString;
end;

procedure TThing._SetaTransient(const NewValue: String);
begin
  M_aTransient.AsString := NewValue;
end;

function TThing._Get_M_one: TBoldObjectReference;
begin
  assert(ValidateMember('TThing', 'one', 1, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[1]);
end;

function TThing._Getone: TThing;
begin
  Result := TThing(M_one.BoldObject);
  assert(not assigned(Result) or (Result is TThing), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'one', Result.ClassName, 'TThing']));
end;

procedure TThing._Setone(const value: TThing);
begin
  M_one.BoldObject := value;
end;

function TThing._Get_M_oneLinkClass: TBoldObjectReference;
begin
  assert(ValidateMember('TThing', 'oneLinkClass', 2, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[2]);
end;

function TThing._GetoneLinkClass: TLinkClass;
begin
  Result := TLinkClass(M_oneLinkClass.BoldObject);
  assert(not assigned(Result) or (Result is TLinkClass), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'oneLinkClass', Result.ClassName, 'TLinkClass']));
end;

function TThing._Getmany: TThingList;
begin
  assert(ValidateMember('TThing', 'many', 3, TThingList));
  Result := TThingList(BoldMembers[3]);
end;

function TThing._GetmanyLinkClass: TLinkClassList;
begin
  assert(ValidateMember('TThing', 'manyLinkClass', 4, TLinkClassList));
  Result := TLinkClassList(BoldMembers[4]);
end;

procedure TThingList.Add(NewObject: TThing);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TThingList.IndexOf(anObject: TThing): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TThingList.Includes(anObject: TThing) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TThingList.AddNew: TThing;
begin
  result := TThing(InternalAddNew);
end;

procedure TThingList.Insert(index: Integer; NewObject: TThing);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TThingList.GetBoldObject(index: Integer): TThing;
begin
  result := TThing(GetElement(index));
end;

procedure TThingList.SetBoldObject(index: Integer; NewObject: TThing);
begin;
  SetElement(index, NewObject);
end;

{$IFDEF UseBoldListEnumerator}
function TThingList.GetEnumerator: TThingListEnumerator;
begin
 Result := TThingListEnumerator.Create(Self);
end;

function TThingListEnumerator.GetCurrent: TThing;
begin
 Result := List[Index] as TThing;
end;

{$ENDIF UseBoldListEnumerator}

{ ThitListsong }

function ThitListsong._Get_M_HitList: TBoldObjectReference;
begin
  assert(ValidateMember('ThitListsong', 'HitList', 0, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[0]);
end;

function ThitListsong._GetHitList: THitList;
begin
  Result := THitList(M_HitList.BoldObject);
  assert(not assigned(Result) or (Result is THitList), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'HitList', Result.ClassName, 'THitList']));
end;

function ThitListsong._Get_M_Song: TBoldObjectReference;
begin
  assert(ValidateMember('ThitListsong', 'Song', 1, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[1]);
end;

function ThitListsong._GetSong: TSong;
begin
  Result := TSong(M_Song.BoldObject);
  assert(not assigned(Result) or (Result is TSong), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'Song', Result.ClassName, 'TSong']));
end;

procedure ThitListsongList.Add(NewObject: ThitListsong);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function ThitListsongList.IndexOf(anObject: ThitListsong): Integer;
begin
  result := IndexOfElement(anObject);
end;

function ThitListsongList.Includes(anObject: ThitListsong) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function ThitListsongList.AddNew: ThitListsong;
begin
  result := ThitListsong(InternalAddNew);
end;

procedure ThitListsongList.Insert(index: Integer; NewObject: ThitListsong);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function ThitListsongList.GetBoldObject(index: Integer): ThitListsong;
begin
  result := ThitListsong(GetElement(index));
end;

procedure ThitListsongList.SetBoldObject(index: Integer; NewObject: ThitListsong);
begin;
  SetElement(index, NewObject);
end;

{$IFDEF UseBoldListEnumerator}
function ThitListsongList.GetEnumerator: ThitListsongListEnumerator;
begin
 Result := ThitListsongListEnumerator.Create(Self);
end;

function ThitListsongListEnumerator.GetCurrent: ThitListsong;
begin
 Result := List[Index] as ThitListsong;
end;

{$ENDIF UseBoldListEnumerator}

{ partpartof }

function partpartof._Get_M_partof: TBoldObjectReference;
begin
  assert(ValidateMember('partpartof', 'partof', 0, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[0]);
end;

function partpartof._Getpartof: TClassA;
begin
  Result := TClassA(M_partof.BoldObject);
  assert(not assigned(Result) or (Result is TClassA), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'partof', Result.ClassName, 'TClassA']));
end;

function partpartof._Get_M_part: TBoldObjectReference;
begin
  assert(ValidateMember('partpartof', 'part', 1, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[1]);
end;

function partpartof._Getpart: TClassA;
begin
  Result := TClassA(M_part.BoldObject);
  assert(not assigned(Result) or (Result is TClassA), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'part', Result.ClassName, 'TClassA']));
end;

procedure partpartofList.Add(NewObject: partpartof);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function partpartofList.IndexOf(anObject: partpartof): Integer;
begin
  result := IndexOfElement(anObject);
end;

function partpartofList.Includes(anObject: partpartof) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function partpartofList.AddNew: partpartof;
begin
  result := partpartof(InternalAddNew);
end;

procedure partpartofList.Insert(index: Integer; NewObject: partpartof);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function partpartofList.GetBoldObject(index: Integer): partpartof;
begin
  result := partpartof(GetElement(index));
end;

procedure partpartofList.SetBoldObject(index: Integer; NewObject: partpartof);
begin;
  SetElement(index, NewObject);
end;

{$IFDEF UseBoldListEnumerator}
function partpartofList.GetEnumerator: partpartofListEnumerator;
begin
 Result := partpartofListEnumerator.Create(Self);
end;

function partpartofListEnumerator.GetCurrent: partpartof;
begin
 Result := List[Index] as partpartof;
end;

{$ENDIF UseBoldListEnumerator}

function GeneratedCodeCRC: String;
begin
  result := '1238220604';
end;

procedure InstallObjectListClasses(BoldObjectListClasses: TBoldGeneratedClassList);
begin
  BoldObjectListClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRootList);
  BoldObjectListClasses.AddObjectEntry('ClassA', TClassAList);
  BoldObjectListClasses.AddObjectEntry('Document', TDocumentList);
  BoldObjectListClasses.AddObjectEntry('HitList', THitListList);
  BoldObjectListClasses.AddObjectEntry('LinkClass', TLinkClassList);
  BoldObjectListClasses.AddObjectEntry('Song', TSongList);
  BoldObjectListClasses.AddObjectEntry('Thing', TThingList);
  BoldObjectListClasses.AddObjectEntry('HitListsong', ThitListsongList);
  BoldObjectListClasses.AddObjectEntry('Partpartof', partpartofList);
end;

procedure InstallBusinessClasses(BoldObjectClasses: TBoldGeneratedClassList);
begin
  BoldObjectClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRoot);
  BoldObjectClasses.AddObjectEntry('ClassA', TClassA);
  BoldObjectClasses.AddObjectEntry('Document', TDocument);
  BoldObjectClasses.AddObjectEntry('HitList', THitList);
  BoldObjectClasses.AddObjectEntry('LinkClass', TLinkClass);
  BoldObjectClasses.AddObjectEntry('Song', TSong);
  BoldObjectClasses.AddObjectEntry('Thing', TThing);
  BoldObjectClasses.AddObjectEntry('HitListsong', ThitListsong);
  BoldObjectClasses.AddObjectEntry('Partpartof', partpartof);
end;

var
  CodeDescriptor: TBoldGeneratedCodeDescriptor;

initialization
  CodeDescriptor := GeneratedCodes.AddGeneratedCodeDescriptorWithFunc('TestModel1_OptimisticLocking', InstallBusinessClasses, InstallObjectListClasses, GeneratedCodeCRC);
finalization
  GeneratedCodes.Remove(CodeDescriptor);
end.
