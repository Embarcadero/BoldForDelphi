(************************************)
(*    This file is autogenerated    *)
(* Any manual changes will be LOST! *)
(************************************)

(* This file should be stored in the same directory    *)
(* as the form/datamodule with the corresponding model *)

// 

{ File generated  }

unit jehoBCBoldTest;

{$DEFINE jehoBCBoldTest_unitheader}
{$INCLUDE jehoBCBoldTest_Interface.inc}

uses
  {ImplementationUses}
  {ImplementationDependancies}
  BoldGeneratedCodeDictionary;

{ Includefile for methodimplementations }

{$INCLUDE jehoBCBoldTest.inc}

const
  BoldMemberAssertSelfAssigned: string = 'Unable to access member %s.%s: Object is not assigned!)';
  BoldMemberAssertInvalidType: string = 'Invalid membertype for %s.%s. Expected %s (code might be out of sync with model)';
  BoldMemberAssertInvalidObjectType: string = 'Object of singlelink (%s.%s) is of wrong type (is %s, should be %s)';
  BoldMemberAssertInvalidDelphiName: string = '%s.%s: Member is incorrect. it is called %s in meta info (code might be out of sync with model)';

{ TBusinessClassesRoot }


procedure TBusinessClassesRootList.Add(NewObject: TBusinessClassesRoot);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TBusinessClassesRootList.IndexOf(anObject: TBusinessClassesRoot): Integer;
begin
  result := IndexOfElement( anObject );
end;

function TBusinessClassesRootList.Includes( anObject: TBusinessClassesRoot ) : Boolean;
begin
  result := IncludesElement( anObject );
end;

procedure TBusinessClassesRootList.Insert(index: Integer; NewObject: TBusinessClassesRoot);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TBusinessClassesRootList.GetBoldObject(index: Integer): TBusinessClassesRoot;
begin
  result := GetElement(index) as TBusinessClassesRoot;
end;

procedure TBusinessClassesRootList.SetBoldObject(index: Integer; NewObject: TBusinessClassesRoot);
begin;
  SetElement( index, NewObject );
end;


{ TClassA }

function TClassA._Get_M_aString: TBAString;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassA', 'aString'] ));
  assert( BoldMembers[0] is TBAString, format( BoldMemberAssertInvalidType, [ClassName, 'aString', 'TBAString'] ));
  assert( BoldMembers[0].BoldMemberRTInfo.DelphiName = 'aString', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aString', BoldMembers[0].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[0] as TBAString;
end;

function TClassA._GetaString: String;
begin
  Result := M_aString.AsString;
end;

procedure TClassA._SetaString(NewValue: String);
begin
  M_aString.AsString := NewValue;
end;

function TClassA._Get_M_aInteger: TBAInteger;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassA', 'aInteger'] ));
  assert( BoldMembers[1] is TBAInteger, format( BoldMemberAssertInvalidType, [ClassName, 'aInteger', 'TBAInteger'] ));
  assert( BoldMembers[1].BoldMemberRTInfo.DelphiName = 'aInteger', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aInteger', BoldMembers[1].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[1] as TBAInteger;
end;

function TClassA._GetaInteger: Integer;
begin
  Result := M_aInteger.AsInteger;
end;

procedure TClassA._SetaInteger(NewValue: Integer);
begin
  M_aInteger.AsInteger := NewValue;
end;

function TClassA._Get_M_aBoolean: TBABoolean;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassA', 'aBoolean'] ));
  assert( BoldMembers[2] is TBABoolean, format( BoldMemberAssertInvalidType, [ClassName, 'aBoolean', 'TBABoolean'] ));
  assert( BoldMembers[2].BoldMemberRTInfo.DelphiName = 'aBoolean', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aBoolean', BoldMembers[2].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[2] as TBABoolean;
end;

function TClassA._GetaBoolean: Boolean;
begin
  Result := M_aBoolean.AsBoolean;
end;

procedure TClassA._SetaBoolean(NewValue: Boolean);
begin
  M_aBoolean.AsBoolean := NewValue;
end;

function TClassA._Get_M_aByte: TBAByte;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassA', 'aByte'] ));
  assert( BoldMembers[3] is TBAByte, format( BoldMemberAssertInvalidType, [ClassName, 'aByte', 'TBAByte'] ));
  assert( BoldMembers[3].BoldMemberRTInfo.DelphiName = 'aByte', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aByte', BoldMembers[3].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[3] as TBAByte;
end;

function TClassA._GetaByte: Byte;
begin
  Result := M_aByte.AsByte;
end;

procedure TClassA._SetaByte(NewValue: Byte);
begin
  M_aByte.AsByte := NewValue;
end;

function TClassA._Get_M_aCurrency: TBACurrency;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassA', 'aCurrency'] ));
  assert( BoldMembers[4] is TBACurrency, format( BoldMemberAssertInvalidType, [ClassName, 'aCurrency', 'TBACurrency'] ));
  assert( BoldMembers[4].BoldMemberRTInfo.DelphiName = 'aCurrency', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aCurrency', BoldMembers[4].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[4] as TBACurrency;
end;

function TClassA._GetaCurrency: Currency;
begin
  Result := M_aCurrency.AsCurrency;
end;

procedure TClassA._SetaCurrency(NewValue: Currency);
begin
  M_aCurrency.AsCurrency := NewValue;
end;

function TClassA._Get_M_aDate: TBADate;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassA', 'aDate'] ));
  assert( BoldMembers[5] is TBADate, format( BoldMemberAssertInvalidType, [ClassName, 'aDate', 'TBADate'] ));
  assert( BoldMembers[5].BoldMemberRTInfo.DelphiName = 'aDate', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aDate', BoldMembers[5].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[5] as TBADate;
end;

function TClassA._GetaDate: TDate;
begin
  Result := M_aDate.AsDate;
end;

procedure TClassA._SetaDate(NewValue: TDate);
begin
  M_aDate.AsDate := NewValue;
end;

function TClassA._Get_M_aDateTime: TBADateTime;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassA', 'aDateTime'] ));
  assert( BoldMembers[6] is TBADateTime, format( BoldMemberAssertInvalidType, [ClassName, 'aDateTime', 'TBADateTime'] ));
  assert( BoldMembers[6].BoldMemberRTInfo.DelphiName = 'aDateTime', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aDateTime', BoldMembers[6].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[6] as TBADateTime;
end;

function TClassA._GetaDateTime: TDateTime;
begin
  Result := M_aDateTime.AsDateTime;
end;

procedure TClassA._SetaDateTime(NewValue: TDateTime);
begin
  M_aDateTime.AsDateTime := NewValue;
end;

function TClassA._Get_M_aFloat: TBAFloat;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassA', 'aFloat'] ));
  assert( BoldMembers[7] is TBAFloat, format( BoldMemberAssertInvalidType, [ClassName, 'aFloat', 'TBAFloat'] ));
  assert( BoldMembers[7].BoldMemberRTInfo.DelphiName = 'aFloat', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aFloat', BoldMembers[7].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[7] as TBAFloat;
end;

function TClassA._GetaFloat: double;
begin
  Result := M_aFloat.AsFloat;
end;

procedure TClassA._SetaFloat(NewValue: double);
begin
  M_aFloat.AsFloat := NewValue;
end;

function TClassA._Get_M_aShortInt: TBAShortInt;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassA', 'aShortInt'] ));
  assert( BoldMembers[8] is TBAShortInt, format( BoldMemberAssertInvalidType, [ClassName, 'aShortInt', 'TBAShortInt'] ));
  assert( BoldMembers[8].BoldMemberRTInfo.DelphiName = 'aShortInt', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aShortInt', BoldMembers[8].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[8] as TBAShortInt;
end;

function TClassA._GetaShortInt: ShortInt;
begin
  Result := M_aShortInt.AsShortInt;
end;

procedure TClassA._SetaShortInt(NewValue: ShortInt);
begin
  M_aShortInt.AsShortInt := NewValue;
end;

function TClassA._Get_M_aSmallInt: TBASmallInt;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassA', 'aSmallInt'] ));
  assert( BoldMembers[9] is TBASmallInt, format( BoldMemberAssertInvalidType, [ClassName, 'aSmallInt', 'TBASmallInt'] ));
  assert( BoldMembers[9].BoldMemberRTInfo.DelphiName = 'aSmallInt', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aSmallInt', BoldMembers[9].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[9] as TBASmallInt;
end;

function TClassA._GetaSmallInt: SmallInt;
begin
  Result := M_aSmallInt.AsSmallInt;
end;

procedure TClassA._SetaSmallInt(NewValue: SmallInt);
begin
  M_aSmallInt.AsSmallInt := NewValue;
end;

function TClassA._Get_M_aTime: TBATime;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassA', 'aTime'] ));
  assert( BoldMembers[10] is TBATime, format( BoldMemberAssertInvalidType, [ClassName, 'aTime', 'TBATime'] ));
  assert( BoldMembers[10].BoldMemberRTInfo.DelphiName = 'aTime', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aTime', BoldMembers[10].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[10] as TBATime;
end;

function TClassA._GetaTime: TTime;
begin
  Result := M_aTime.AsTime;
end;

procedure TClassA._SetaTime(NewValue: TTime);
begin
  M_aTime.AsTime := NewValue;
end;

function TClassA._Get_M_aWord: TBAWord;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassA', 'aWord'] ));
  assert( BoldMembers[11] is TBAWord, format( BoldMemberAssertInvalidType, [ClassName, 'aWord', 'TBAWord'] ));
  assert( BoldMembers[11].BoldMemberRTInfo.DelphiName = 'aWord', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aWord', BoldMembers[11].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[11] as TBAWord;
end;

function TClassA._GetaWord: Word;
begin
  Result := M_aWord.AsWord;
end;

procedure TClassA._SetaWord(NewValue: Word);
begin
  M_aWord.AsWord := NewValue;
end;

function TClassA._Get_M_aBlob: TBABlob;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassA', 'aBlob'] ));
  assert( BoldMembers[12] is TBABlob, format( BoldMemberAssertInvalidType, [ClassName, 'aBlob', 'TBABlob'] ));
  assert( BoldMembers[12].BoldMemberRTInfo.DelphiName = 'aBlob', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aBlob', BoldMembers[12].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[12] as TBABlob;
end;

function TClassA._GetaBlob: String;
begin
  Result := M_aBlob.AsString;
end;

procedure TClassA._SetaBlob(NewValue: String);
begin
  M_aBlob.AsString := NewValue;
end;

function TClassA._Get_M_aBlobContent: TBATypedBlob;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassA', 'aBlobContent'] ));
  assert( BoldMembers[13] is TBATypedBlob, format( BoldMemberAssertInvalidType, [ClassName, 'aBlobContent', 'TBATypedBlob'] ));
  assert( BoldMembers[13].BoldMemberRTInfo.DelphiName = 'aBlobContent', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aBlobContent', BoldMembers[13].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[13] as TBATypedBlob;
end;

function TClassA._GetaBlobContent: String;
begin
  Result := M_aBlobContent.AsString;
end;

procedure TClassA._SetaBlobContent(NewValue: String);
begin
  M_aBlobContent.AsString := NewValue;
end;


procedure TClassAList.Add(NewObject: TClassA);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TClassAList.IndexOf(anObject: TClassA): Integer;
begin
  result := IndexOfElement( anObject );
end;

function TClassAList.Includes( anObject: TClassA ) : Boolean;
begin
  result := IncludesElement( anObject );
end;

procedure TClassAList.Insert(index: Integer; NewObject: TClassA);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TClassAList.GetBoldObject(index: Integer): TClassA;
begin
  result := GetElement(index) as TClassA;
end;

procedure TClassAList.SetBoldObject(index: Integer; NewObject: TClassA);
begin;
  SetElement( index, NewObject );
end;


{ TClassB }

function TClassB._Get_M_bString: TBAString;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassB', 'bString'] ));
  assert( BoldMembers[14] is TBAString, format( BoldMemberAssertInvalidType, [ClassName, 'bString', 'TBAString'] ));
  assert( BoldMembers[14].BoldMemberRTInfo.DelphiName = 'bString', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'bString', BoldMembers[14].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[14] as TBAString;
end;

function TClassB._GetbString: String;
begin
  Result := M_bString.AsString;
end;

procedure TClassB._SetbString(NewValue: String);
begin
  M_bString.AsString := NewValue;
end;

function TClassB._Get_M_bBlob: TBABlob;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassB', 'bBlob'] ));
  assert( BoldMembers[15] is TBABlob, format( BoldMemberAssertInvalidType, [ClassName, 'bBlob', 'TBABlob'] ));
  assert( BoldMembers[15].BoldMemberRTInfo.DelphiName = 'bBlob', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'bBlob', BoldMembers[15].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[15] as TBABlob;
end;

function TClassB._GetbBlob: String;
begin
  Result := M_bBlob.AsString;
end;

procedure TClassB._SetbBlob(NewValue: String);
begin
  M_bBlob.AsString := NewValue;
end;

function TClassB._Get_M_bBlobContent: TBATypedBlob;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassB', 'bBlobContent'] ));
  assert( BoldMembers[16] is TBATypedBlob, format( BoldMemberAssertInvalidType, [ClassName, 'bBlobContent', 'TBATypedBlob'] ));
  assert( BoldMembers[16].BoldMemberRTInfo.DelphiName = 'bBlobContent', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'bBlobContent', BoldMembers[16].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[16] as TBATypedBlob;
end;

function TClassB._GetbBlobContent: String;
begin
  Result := M_bBlobContent.AsString;
end;

procedure TClassB._SetbBlobContent(NewValue: String);
begin
  M_bBlobContent.AsString := NewValue;
end;

function TClassB._Get_M_bBoolean: TBABoolean;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassB', 'bBoolean'] ));
  assert( BoldMembers[17] is TBABoolean, format( BoldMemberAssertInvalidType, [ClassName, 'bBoolean', 'TBABoolean'] ));
  assert( BoldMembers[17].BoldMemberRTInfo.DelphiName = 'bBoolean', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'bBoolean', BoldMembers[17].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[17] as TBABoolean;
end;

function TClassB._GetbBoolean: Boolean;
begin
  Result := M_bBoolean.AsBoolean;
end;

procedure TClassB._SetbBoolean(NewValue: Boolean);
begin
  M_bBoolean.AsBoolean := NewValue;
end;

function TClassB._Get_M_bByte: TBAByte;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassB', 'bByte'] ));
  assert( BoldMembers[18] is TBAByte, format( BoldMemberAssertInvalidType, [ClassName, 'bByte', 'TBAByte'] ));
  assert( BoldMembers[18].BoldMemberRTInfo.DelphiName = 'bByte', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'bByte', BoldMembers[18].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[18] as TBAByte;
end;

function TClassB._GetbByte: Byte;
begin
  Result := M_bByte.AsByte;
end;

procedure TClassB._SetbByte(NewValue: Byte);
begin
  M_bByte.AsByte := NewValue;
end;

function TClassB._Get_M_bCurrency: TBACurrency;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassB', 'bCurrency'] ));
  assert( BoldMembers[19] is TBACurrency, format( BoldMemberAssertInvalidType, [ClassName, 'bCurrency', 'TBACurrency'] ));
  assert( BoldMembers[19].BoldMemberRTInfo.DelphiName = 'bCurrency', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'bCurrency', BoldMembers[19].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[19] as TBACurrency;
end;

function TClassB._GetbCurrency: Currency;
begin
  Result := M_bCurrency.AsCurrency;
end;

procedure TClassB._SetbCurrency(NewValue: Currency);
begin
  M_bCurrency.AsCurrency := NewValue;
end;

function TClassB._Get_M_bDate: TBADate;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassB', 'bDate'] ));
  assert( BoldMembers[20] is TBADate, format( BoldMemberAssertInvalidType, [ClassName, 'bDate', 'TBADate'] ));
  assert( BoldMembers[20].BoldMemberRTInfo.DelphiName = 'bDate', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'bDate', BoldMembers[20].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[20] as TBADate;
end;

function TClassB._GetbDate: TDate;
begin
  Result := M_bDate.AsDate;
end;

procedure TClassB._SetbDate(NewValue: TDate);
begin
  M_bDate.AsDate := NewValue;
end;

function TClassB._Get_M_bDateTime: TBADateTime;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassB', 'bDateTime'] ));
  assert( BoldMembers[21] is TBADateTime, format( BoldMemberAssertInvalidType, [ClassName, 'bDateTime', 'TBADateTime'] ));
  assert( BoldMembers[21].BoldMemberRTInfo.DelphiName = 'bDateTime', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'bDateTime', BoldMembers[21].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[21] as TBADateTime;
end;

function TClassB._GetbDateTime: TDateTime;
begin
  Result := M_bDateTime.AsDateTime;
end;

procedure TClassB._SetbDateTime(NewValue: TDateTime);
begin
  M_bDateTime.AsDateTime := NewValue;
end;

function TClassB._Get_M_bInteger: TBAInteger;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassB', 'bInteger'] ));
  assert( BoldMembers[22] is TBAInteger, format( BoldMemberAssertInvalidType, [ClassName, 'bInteger', 'TBAInteger'] ));
  assert( BoldMembers[22].BoldMemberRTInfo.DelphiName = 'bInteger', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'bInteger', BoldMembers[22].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[22] as TBAInteger;
end;

function TClassB._GetbInteger: Integer;
begin
  Result := M_bInteger.AsInteger;
end;

procedure TClassB._SetbInteger(NewValue: Integer);
begin
  M_bInteger.AsInteger := NewValue;
end;

function TClassB._Get_M_bFloat: TBAFloat;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassB', 'bFloat'] ));
  assert( BoldMembers[23] is TBAFloat, format( BoldMemberAssertInvalidType, [ClassName, 'bFloat', 'TBAFloat'] ));
  assert( BoldMembers[23].BoldMemberRTInfo.DelphiName = 'bFloat', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'bFloat', BoldMembers[23].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[23] as TBAFloat;
end;

function TClassB._GetbFloat: double;
begin
  Result := M_bFloat.AsFloat;
end;

procedure TClassB._SetbFloat(NewValue: double);
begin
  M_bFloat.AsFloat := NewValue;
end;

function TClassB._Get_M_bShortInt: TBAShortInt;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassB', 'bShortInt'] ));
  assert( BoldMembers[24] is TBAShortInt, format( BoldMemberAssertInvalidType, [ClassName, 'bShortInt', 'TBAShortInt'] ));
  assert( BoldMembers[24].BoldMemberRTInfo.DelphiName = 'bShortInt', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'bShortInt', BoldMembers[24].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[24] as TBAShortInt;
end;

function TClassB._GetbShortInt: ShortInt;
begin
  Result := M_bShortInt.AsShortInt;
end;

procedure TClassB._SetbShortInt(NewValue: ShortInt);
begin
  M_bShortInt.AsShortInt := NewValue;
end;

function TClassB._Get_M_bSmallInt: TBASmallInt;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassB', 'bSmallInt'] ));
  assert( BoldMembers[25] is TBASmallInt, format( BoldMemberAssertInvalidType, [ClassName, 'bSmallInt', 'TBASmallInt'] ));
  assert( BoldMembers[25].BoldMemberRTInfo.DelphiName = 'bSmallInt', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'bSmallInt', BoldMembers[25].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[25] as TBASmallInt;
end;

function TClassB._GetbSmallInt: SmallInt;
begin
  Result := M_bSmallInt.AsSmallInt;
end;

procedure TClassB._SetbSmallInt(NewValue: SmallInt);
begin
  M_bSmallInt.AsSmallInt := NewValue;
end;

function TClassB._Get_M_bTIme: TBATime;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassB', 'bTIme'] ));
  assert( BoldMembers[26] is TBATime, format( BoldMemberAssertInvalidType, [ClassName, 'bTIme', 'TBATime'] ));
  assert( BoldMembers[26].BoldMemberRTInfo.DelphiName = 'bTIme', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'bTIme', BoldMembers[26].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[26] as TBATime;
end;

function TClassB._GetbTIme: TTime;
begin
  Result := M_bTIme.AsTime;
end;

procedure TClassB._SetbTIme(NewValue: TTime);
begin
  M_bTIme.AsTime := NewValue;
end;

function TClassB._Get_M_bWord: TBAWord;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassB', 'bWord'] ));
  assert( BoldMembers[27] is TBAWord, format( BoldMemberAssertInvalidType, [ClassName, 'bWord', 'TBAWord'] ));
  assert( BoldMembers[27].BoldMemberRTInfo.DelphiName = 'bWord', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'bWord', BoldMembers[27].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[27] as TBAWord;
end;

function TClassB._GetbWord: Word;
begin
  Result := M_bWord.AsWord;
end;

procedure TClassB._SetbWord(NewValue: Word);
begin
  M_bWord.AsWord := NewValue;
end;


procedure TClassBList.Add(NewObject: TClassB);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TClassBList.IndexOf(anObject: TClassB): Integer;
begin
  result := IndexOfElement( anObject );
end;

function TClassBList.Includes( anObject: TClassB ) : Boolean;
begin
  result := IncludesElement( anObject );
end;

procedure TClassBList.Insert(index: Integer; NewObject: TClassB);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TClassBList.GetBoldObject(index: Integer): TClassB;
begin
  result := GetElement(index) as TClassB;
end;

procedure TClassBList.SetBoldObject(index: Integer; NewObject: TClassB);
begin;
  SetElement( index, NewObject );
end;


{ TClassDerivedA }

function TClassDerivedA._Get_M_aDerivedString: TBAString;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassDerivedA', 'aDerivedString'] ));
  assert( BoldMembers[14] is TBAString, format( BoldMemberAssertInvalidType, [ClassName, 'aDerivedString', 'TBAString'] ));
  assert( BoldMembers[14].BoldMemberRTInfo.DelphiName = 'aDerivedString', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aDerivedString', BoldMembers[14].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[14] as TBAString;
end;

function TClassDerivedA._GetaDerivedString: String;
begin
  Result := M_aDerivedString.AsString;
end;


function TClassDerivedA._Get_M_aDerivedInteger: TBAInteger;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassDerivedA', 'aDerivedInteger'] ));
  assert( BoldMembers[15] is TBAInteger, format( BoldMemberAssertInvalidType, [ClassName, 'aDerivedInteger', 'TBAInteger'] ));
  assert( BoldMembers[15].BoldMemberRTInfo.DelphiName = 'aDerivedInteger', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aDerivedInteger', BoldMembers[15].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[15] as TBAInteger;
end;

function TClassDerivedA._GetaDerivedInteger: Integer;
begin
  Result := M_aDerivedInteger.AsInteger;
end;


function TClassDerivedA._Get_M_aDerivedBoolean: TBABoolean;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassDerivedA', 'aDerivedBoolean'] ));
  assert( BoldMembers[16] is TBABoolean, format( BoldMemberAssertInvalidType, [ClassName, 'aDerivedBoolean', 'TBABoolean'] ));
  assert( BoldMembers[16].BoldMemberRTInfo.DelphiName = 'aDerivedBoolean', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aDerivedBoolean', BoldMembers[16].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[16] as TBABoolean;
end;

function TClassDerivedA._GetaDerivedBoolean: Boolean;
begin
  Result := M_aDerivedBoolean.AsBoolean;
end;


function TClassDerivedA._Get_M_aDerivedByte: TBAByte;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassDerivedA', 'aDerivedByte'] ));
  assert( BoldMembers[17] is TBAByte, format( BoldMemberAssertInvalidType, [ClassName, 'aDerivedByte', 'TBAByte'] ));
  assert( BoldMembers[17].BoldMemberRTInfo.DelphiName = 'aDerivedByte', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aDerivedByte', BoldMembers[17].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[17] as TBAByte;
end;

function TClassDerivedA._GetaDerivedByte: Byte;
begin
  Result := M_aDerivedByte.AsByte;
end;


function TClassDerivedA._Get_M_aDerivedCurrency: TBACurrency;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassDerivedA', 'aDerivedCurrency'] ));
  assert( BoldMembers[18] is TBACurrency, format( BoldMemberAssertInvalidType, [ClassName, 'aDerivedCurrency', 'TBACurrency'] ));
  assert( BoldMembers[18].BoldMemberRTInfo.DelphiName = 'aDerivedCurrency', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aDerivedCurrency', BoldMembers[18].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[18] as TBACurrency;
end;

function TClassDerivedA._GetaDerivedCurrency: Currency;
begin
  Result := M_aDerivedCurrency.AsCurrency;
end;


function TClassDerivedA._Get_M_aDerivedDate: TBADate;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassDerivedA', 'aDerivedDate'] ));
  assert( BoldMembers[19] is TBADate, format( BoldMemberAssertInvalidType, [ClassName, 'aDerivedDate', 'TBADate'] ));
  assert( BoldMembers[19].BoldMemberRTInfo.DelphiName = 'aDerivedDate', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aDerivedDate', BoldMembers[19].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[19] as TBADate;
end;

function TClassDerivedA._GetaDerivedDate: TDate;
begin
  Result := M_aDerivedDate.AsDate;
end;


function TClassDerivedA._Get_M_aDerivedDateTime: TBADateTime;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassDerivedA', 'aDerivedDateTime'] ));
  assert( BoldMembers[20] is TBADateTime, format( BoldMemberAssertInvalidType, [ClassName, 'aDerivedDateTime', 'TBADateTime'] ));
  assert( BoldMembers[20].BoldMemberRTInfo.DelphiName = 'aDerivedDateTime', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aDerivedDateTime', BoldMembers[20].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[20] as TBADateTime;
end;

function TClassDerivedA._GetaDerivedDateTime: TDateTime;
begin
  Result := M_aDerivedDateTime.AsDateTime;
end;


function TClassDerivedA._Get_M_aDerivedFloat: TBAFloat;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassDerivedA', 'aDerivedFloat'] ));
  assert( BoldMembers[21] is TBAFloat, format( BoldMemberAssertInvalidType, [ClassName, 'aDerivedFloat', 'TBAFloat'] ));
  assert( BoldMembers[21].BoldMemberRTInfo.DelphiName = 'aDerivedFloat', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aDerivedFloat', BoldMembers[21].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[21] as TBAFloat;
end;

function TClassDerivedA._GetaDerivedFloat: double;
begin
  Result := M_aDerivedFloat.AsFloat;
end;


function TClassDerivedA._Get_M_aDerivedShortInt: TBAShortInt;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassDerivedA', 'aDerivedShortInt'] ));
  assert( BoldMembers[22] is TBAShortInt, format( BoldMemberAssertInvalidType, [ClassName, 'aDerivedShortInt', 'TBAShortInt'] ));
  assert( BoldMembers[22].BoldMemberRTInfo.DelphiName = 'aDerivedShortInt', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aDerivedShortInt', BoldMembers[22].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[22] as TBAShortInt;
end;

function TClassDerivedA._GetaDerivedShortInt: ShortInt;
begin
  Result := M_aDerivedShortInt.AsShortInt;
end;


function TClassDerivedA._Get_M_aDerivedSmallInt: TBASmallInt;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassDerivedA', 'aDerivedSmallInt'] ));
  assert( BoldMembers[23] is TBASmallInt, format( BoldMemberAssertInvalidType, [ClassName, 'aDerivedSmallInt', 'TBASmallInt'] ));
  assert( BoldMembers[23].BoldMemberRTInfo.DelphiName = 'aDerivedSmallInt', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aDerivedSmallInt', BoldMembers[23].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[23] as TBASmallInt;
end;

function TClassDerivedA._GetaDerivedSmallInt: SmallInt;
begin
  Result := M_aDerivedSmallInt.AsSmallInt;
end;


function TClassDerivedA._Get_M_aDerivedTime: TBATime;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassDerivedA', 'aDerivedTime'] ));
  assert( BoldMembers[24] is TBATime, format( BoldMemberAssertInvalidType, [ClassName, 'aDerivedTime', 'TBATime'] ));
  assert( BoldMembers[24].BoldMemberRTInfo.DelphiName = 'aDerivedTime', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aDerivedTime', BoldMembers[24].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[24] as TBATime;
end;

function TClassDerivedA._GetaDerivedTime: TTime;
begin
  Result := M_aDerivedTime.AsTime;
end;


function TClassDerivedA._Get_M_ADerivedWord: TBAWord;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassDerivedA', 'ADerivedWord'] ));
  assert( BoldMembers[25] is TBAWord, format( BoldMemberAssertInvalidType, [ClassName, 'ADerivedWord', 'TBAWord'] ));
  assert( BoldMembers[25].BoldMemberRTInfo.DelphiName = 'ADerivedWord', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'ADerivedWord', BoldMembers[25].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[25] as TBAWord;
end;

function TClassDerivedA._GetADerivedWord: Word;
begin
  Result := M_ADerivedWord.AsWord;
end;


function TClassDerivedA._Get_M_ADerivedBlob: TBABlob;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassDerivedA', 'ADerivedBlob'] ));
  assert( BoldMembers[26] is TBABlob, format( BoldMemberAssertInvalidType, [ClassName, 'ADerivedBlob', 'TBABlob'] ));
  assert( BoldMembers[26].BoldMemberRTInfo.DelphiName = 'ADerivedBlob', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'ADerivedBlob', BoldMembers[26].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[26] as TBABlob;
end;

function TClassDerivedA._GetADerivedBlob: String;
begin
  Result := M_ADerivedBlob.AsString;
end;


function TClassDerivedA._Get_M_aDerivedBlobContent: TBATypedBlob;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassDerivedA', 'aDerivedBlobContent'] ));
  assert( BoldMembers[27] is TBATypedBlob, format( BoldMemberAssertInvalidType, [ClassName, 'aDerivedBlobContent', 'TBATypedBlob'] ));
  assert( BoldMembers[27].BoldMemberRTInfo.DelphiName = 'aDerivedBlobContent', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aDerivedBlobContent', BoldMembers[27].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[27] as TBATypedBlob;
end;

function TClassDerivedA._GetaDerivedBlobContent: String;
begin
  Result := M_aDerivedBlobContent.AsString;
end;



procedure TClassDerivedAList.Add(NewObject: TClassDerivedA);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TClassDerivedAList.IndexOf(anObject: TClassDerivedA): Integer;
begin
  result := IndexOfElement( anObject );
end;

function TClassDerivedAList.Includes( anObject: TClassDerivedA ) : Boolean;
begin
  result := IncludesElement( anObject );
end;

procedure TClassDerivedAList.Insert(index: Integer; NewObject: TClassDerivedA);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TClassDerivedAList.GetBoldObject(index: Integer): TClassDerivedA;
begin
  result := GetElement(index) as TClassDerivedA;
end;

procedure TClassDerivedAList.SetBoldObject(index: Integer; NewObject: TClassDerivedA);
begin;
  SetElement( index, NewObject );
end;


{procedure TClassDerivedA.InitializeDerivedMembers;
begin
  inherited;
  M_aDerivedString.Deriver.OnDeriveAndSubscribe := _aDerivedString_DeriveAndSubscribe;
  M_aDerivedInteger.Deriver.OnDeriveAndSubscribe := _aDerivedInteger_DeriveAndSubscribe;
  M_aDerivedBoolean.Deriver.OnDeriveAndSubscribe := _aDerivedBoolean_DeriveAndSubscribe;
  M_aDerivedByte.Deriver.OnDeriveAndSubscribe := _aDerivedByte_DeriveAndSubscribe;
  M_aDerivedCurrency.Deriver.OnDeriveAndSubscribe := _aDerivedCurrency_DeriveAndSubscribe;
  M_aDerivedDate.Deriver.OnDeriveAndSubscribe := _aDerivedDate_DeriveAndSubscribe;
  M_aDerivedDateTime.Deriver.OnDeriveAndSubscribe := _aDerivedDateTime_DeriveAndSubscribe;
  M_aDerivedFloat.Deriver.OnDeriveAndSubscribe := _aDerivedFloat_DeriveAndSubscribe;
  M_aDerivedShortInt.Deriver.OnDeriveAndSubscribe := _aDerivedShortInt_DeriveAndSubscribe;
  M_aDerivedSmallInt.Deriver.OnDeriveAndSubscribe := _aDerivedSmallInt_DeriveAndSubscribe;
  M_aDerivedTime.Deriver.OnDeriveAndSubscribe := _aDerivedTime_DeriveAndSubscribe;
  M_ADerivedWord.Deriver.OnDeriveAndSubscribe := _ADerivedWord_DeriveAndSubscribe;
  M_ADerivedBlob.Deriver.OnDeriveAndSubscribe := _ADerivedBlob_DeriveAndSubscribe;
  M_aDerivedBlobContent.Deriver.OnDeriveAndSubscribe := _aDerivedBlobContent_DeriveAndSubscribe;
end;}

function TClassDerivedA.GetDeriveMethodForMember( Member: TBoldMember ): TBoldDeriveAndResubscribe;
begin
  result := nil;
  if not assigned( result ) and (member = M_aDerivedString) then result := _aDerivedString_DeriveAndSubscribe;
  if not assigned( result ) then result := inherited GetDeriveMethodForMember( member );
  if not assigned( result ) and (member = M_aDerivedInteger) then result := _aDerivedInteger_DeriveAndSubscribe;
  if not assigned( result ) then result := inherited GetDeriveMethodForMember( member );
  if not assigned( result ) and (member = M_aDerivedBoolean) then result := _aDerivedBoolean_DeriveAndSubscribe;
  if not assigned( result ) then result := inherited GetDeriveMethodForMember( member );
  if not assigned( result ) and (member = M_aDerivedByte) then result := _aDerivedByte_DeriveAndSubscribe;
  if not assigned( result ) then result := inherited GetDeriveMethodForMember( member );
  if not assigned( result ) and (member = M_aDerivedCurrency) then result := _aDerivedCurrency_DeriveAndSubscribe;
  if not assigned( result ) then result := inherited GetDeriveMethodForMember( member );
  if not assigned( result ) and (member = M_aDerivedDate) then result := _aDerivedDate_DeriveAndSubscribe;
  if not assigned( result ) then result := inherited GetDeriveMethodForMember( member );
  if not assigned( result ) and (member = M_aDerivedDateTime) then result := _aDerivedDateTime_DeriveAndSubscribe;
  if not assigned( result ) then result := inherited GetDeriveMethodForMember( member );
  if not assigned( result ) and (member = M_aDerivedFloat) then result := _aDerivedFloat_DeriveAndSubscribe;
  if not assigned( result ) then result := inherited GetDeriveMethodForMember( member );
  if not assigned( result ) and (member = M_aDerivedShortInt) then result := _aDerivedShortInt_DeriveAndSubscribe;
  if not assigned( result ) then result := inherited GetDeriveMethodForMember( member );
  if not assigned( result ) and (member = M_aDerivedSmallInt) then result := _aDerivedSmallInt_DeriveAndSubscribe;
  if not assigned( result ) then result := inherited GetDeriveMethodForMember( member );
  if not assigned( result ) and (member = M_aDerivedTime) then result := _aDerivedTime_DeriveAndSubscribe;
  if not assigned( result ) then result := inherited GetDeriveMethodForMember( member );
  if not assigned( result ) and (member = M_ADerivedWord) then result := _ADerivedWord_DeriveAndSubscribe;
  if not assigned( result ) then result := inherited GetDeriveMethodForMember( member );
  if not assigned( result ) and (member = M_ADerivedBlob) then result := _ADerivedBlob_DeriveAndSubscribe;
  if not assigned( result ) then result := inherited GetDeriveMethodForMember( member );
  if not assigned( result ) and (member = M_aDerivedBlobContent) then result := _aDerivedBlobContent_DeriveAndSubscribe;
  if not assigned( result ) then result := inherited GetDeriveMethodForMember( member );
end;

function TClassDerivedA.GetReverseDeriveMethodForMember( Member: TBoldMember ): TBoldReverseDerive;
begin
  result := inherited GetReverseDeriveMethodForMember( member );
end;
{ TClassOclDerivedA }

function TClassOclDerivedA._Get_M_aOclDerivedBlob: TBABlob;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassOclDerivedA', 'aOclDerivedBlob'] ));
  assert( BoldMembers[14] is TBABlob, format( BoldMemberAssertInvalidType, [ClassName, 'aOclDerivedBlob', 'TBABlob'] ));
  assert( BoldMembers[14].BoldMemberRTInfo.DelphiName = 'aOclDerivedBlob', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aOclDerivedBlob', BoldMembers[14].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[14] as TBABlob;
end;

function TClassOclDerivedA._GetaOclDerivedBlob: String;
begin
  Result := M_aOclDerivedBlob.AsString;
end;


function TClassOclDerivedA._Get_M_aOclDerivedBlobContent: TBATypedBlob;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassOclDerivedA', 'aOclDerivedBlobContent'] ));
  assert( BoldMembers[15] is TBATypedBlob, format( BoldMemberAssertInvalidType, [ClassName, 'aOclDerivedBlobContent', 'TBATypedBlob'] ));
  assert( BoldMembers[15].BoldMemberRTInfo.DelphiName = 'aOclDerivedBlobContent', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aOclDerivedBlobContent', BoldMembers[15].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[15] as TBATypedBlob;
end;

function TClassOclDerivedA._GetaOclDerivedBlobContent: String;
begin
  Result := M_aOclDerivedBlobContent.AsString;
end;


function TClassOclDerivedA._Get_M_aOclDerivedBoolean: TBABoolean;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassOclDerivedA', 'aOclDerivedBoolean'] ));
  assert( BoldMembers[16] is TBABoolean, format( BoldMemberAssertInvalidType, [ClassName, 'aOclDerivedBoolean', 'TBABoolean'] ));
  assert( BoldMembers[16].BoldMemberRTInfo.DelphiName = 'aOclDerivedBoolean', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aOclDerivedBoolean', BoldMembers[16].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[16] as TBABoolean;
end;

function TClassOclDerivedA._GetaOclDerivedBoolean: Boolean;
begin
  Result := M_aOclDerivedBoolean.AsBoolean;
end;


function TClassOclDerivedA._Get_M_aOclDerivedByte: TBAByte;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassOclDerivedA', 'aOclDerivedByte'] ));
  assert( BoldMembers[17] is TBAByte, format( BoldMemberAssertInvalidType, [ClassName, 'aOclDerivedByte', 'TBAByte'] ));
  assert( BoldMembers[17].BoldMemberRTInfo.DelphiName = 'aOclDerivedByte', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aOclDerivedByte', BoldMembers[17].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[17] as TBAByte;
end;

function TClassOclDerivedA._GetaOclDerivedByte: Byte;
begin
  Result := M_aOclDerivedByte.AsByte;
end;


function TClassOclDerivedA._Get_M_aOclDerivedCurrency: TBACurrency;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassOclDerivedA', 'aOclDerivedCurrency'] ));
  assert( BoldMembers[18] is TBACurrency, format( BoldMemberAssertInvalidType, [ClassName, 'aOclDerivedCurrency', 'TBACurrency'] ));
  assert( BoldMembers[18].BoldMemberRTInfo.DelphiName = 'aOclDerivedCurrency', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aOclDerivedCurrency', BoldMembers[18].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[18] as TBACurrency;
end;

function TClassOclDerivedA._GetaOclDerivedCurrency: Currency;
begin
  Result := M_aOclDerivedCurrency.AsCurrency;
end;


function TClassOclDerivedA._Get_M_aOclDerivedDateTime: TBADateTime;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassOclDerivedA', 'aOclDerivedDateTime'] ));
  assert( BoldMembers[19] is TBADateTime, format( BoldMemberAssertInvalidType, [ClassName, 'aOclDerivedDateTime', 'TBADateTime'] ));
  assert( BoldMembers[19].BoldMemberRTInfo.DelphiName = 'aOclDerivedDateTime', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aOclDerivedDateTime', BoldMembers[19].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[19] as TBADateTime;
end;

function TClassOclDerivedA._GetaOclDerivedDateTime: TDateTime;
begin
  Result := M_aOclDerivedDateTime.AsDateTime;
end;


function TClassOclDerivedA._Get_M_aOclDerivedFloat: TBAFloat;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassOclDerivedA', 'aOclDerivedFloat'] ));
  assert( BoldMembers[20] is TBAFloat, format( BoldMemberAssertInvalidType, [ClassName, 'aOclDerivedFloat', 'TBAFloat'] ));
  assert( BoldMembers[20].BoldMemberRTInfo.DelphiName = 'aOclDerivedFloat', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aOclDerivedFloat', BoldMembers[20].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[20] as TBAFloat;
end;

function TClassOclDerivedA._GetaOclDerivedFloat: double;
begin
  Result := M_aOclDerivedFloat.AsFloat;
end;


function TClassOclDerivedA._Get_M_aOclDerivedInteger: TBAInteger;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassOclDerivedA', 'aOclDerivedInteger'] ));
  assert( BoldMembers[21] is TBAInteger, format( BoldMemberAssertInvalidType, [ClassName, 'aOclDerivedInteger', 'TBAInteger'] ));
  assert( BoldMembers[21].BoldMemberRTInfo.DelphiName = 'aOclDerivedInteger', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aOclDerivedInteger', BoldMembers[21].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[21] as TBAInteger;
end;

function TClassOclDerivedA._GetaOclDerivedInteger: Integer;
begin
  Result := M_aOclDerivedInteger.AsInteger;
end;


function TClassOclDerivedA._Get_M_aOclDerivedShortInt: TBAShortInt;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassOclDerivedA', 'aOclDerivedShortInt'] ));
  assert( BoldMembers[22] is TBAShortInt, format( BoldMemberAssertInvalidType, [ClassName, 'aOclDerivedShortInt', 'TBAShortInt'] ));
  assert( BoldMembers[22].BoldMemberRTInfo.DelphiName = 'aOclDerivedShortInt', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aOclDerivedShortInt', BoldMembers[22].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[22] as TBAShortInt;
end;

function TClassOclDerivedA._GetaOclDerivedShortInt: ShortInt;
begin
  Result := M_aOclDerivedShortInt.AsShortInt;
end;


function TClassOclDerivedA._Get_M_aOclDerivedSmallInt: TBASmallInt;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassOclDerivedA', 'aOclDerivedSmallInt'] ));
  assert( BoldMembers[23] is TBASmallInt, format( BoldMemberAssertInvalidType, [ClassName, 'aOclDerivedSmallInt', 'TBASmallInt'] ));
  assert( BoldMembers[23].BoldMemberRTInfo.DelphiName = 'aOclDerivedSmallInt', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aOclDerivedSmallInt', BoldMembers[23].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[23] as TBASmallInt;
end;

function TClassOclDerivedA._GetaOclDerivedSmallInt: SmallInt;
begin
  Result := M_aOclDerivedSmallInt.AsSmallInt;
end;


function TClassOclDerivedA._Get_M_aOclDerivedString: TBAString;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassOclDerivedA', 'aOclDerivedString'] ));
  assert( BoldMembers[24] is TBAString, format( BoldMemberAssertInvalidType, [ClassName, 'aOclDerivedString', 'TBAString'] ));
  assert( BoldMembers[24].BoldMemberRTInfo.DelphiName = 'aOclDerivedString', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aOclDerivedString', BoldMembers[24].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[24] as TBAString;
end;

function TClassOclDerivedA._GetaOclDerivedString: String;
begin
  Result := M_aOclDerivedString.AsString;
end;


function TClassOclDerivedA._Get_M_aOclDerivedTime: TBATime;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassOclDerivedA', 'aOclDerivedTime'] ));
  assert( BoldMembers[25] is TBATime, format( BoldMemberAssertInvalidType, [ClassName, 'aOclDerivedTime', 'TBATime'] ));
  assert( BoldMembers[25].BoldMemberRTInfo.DelphiName = 'aOclDerivedTime', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aOclDerivedTime', BoldMembers[25].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[25] as TBATime;
end;

function TClassOclDerivedA._GetaOclDerivedTime: TTime;
begin
  Result := M_aOclDerivedTime.AsTime;
end;


function TClassOclDerivedA._Get_M_aOclDerivedWord: TBAWord;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassOclDerivedA', 'aOclDerivedWord'] ));
  assert( BoldMembers[26] is TBAWord, format( BoldMemberAssertInvalidType, [ClassName, 'aOclDerivedWord', 'TBAWord'] ));
  assert( BoldMembers[26].BoldMemberRTInfo.DelphiName = 'aOclDerivedWord', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aOclDerivedWord', BoldMembers[26].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[26] as TBAWord;
end;

function TClassOclDerivedA._GetaOclDerivedWord: Word;
begin
  Result := M_aOclDerivedWord.AsWord;
end;


function TClassOclDerivedA._Get_M_aOclDerivedDate: TBADate;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassOclDerivedA', 'aOclDerivedDate'] ));
  assert( BoldMembers[27] is TBADate, format( BoldMemberAssertInvalidType, [ClassName, 'aOclDerivedDate', 'TBADate'] ));
  assert( BoldMembers[27].BoldMemberRTInfo.DelphiName = 'aOclDerivedDate', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aOclDerivedDate', BoldMembers[27].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[27] as TBADate;
end;

function TClassOclDerivedA._GetaOclDerivedDate: TDate;
begin
  Result := M_aOclDerivedDate.AsDate;
end;



procedure TClassOclDerivedAList.Add(NewObject: TClassOclDerivedA);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TClassOclDerivedAList.IndexOf(anObject: TClassOclDerivedA): Integer;
begin
  result := IndexOfElement( anObject );
end;

function TClassOclDerivedAList.Includes( anObject: TClassOclDerivedA ) : Boolean;
begin
  result := IncludesElement( anObject );
end;

procedure TClassOclDerivedAList.Insert(index: Integer; NewObject: TClassOclDerivedA);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TClassOclDerivedAList.GetBoldObject(index: Integer): TClassOclDerivedA;
begin
  result := GetElement(index) as TClassOclDerivedA;
end;

procedure TClassOclDerivedAList.SetBoldObject(index: Integer; NewObject: TClassOclDerivedA);
begin;
  SetElement( index, NewObject );
end;


{ TClassMultiDerivedA }

function TClassMultiDerivedA._Get_M_aMultiDerivedBoolean: TBABoolean;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassMultiDerivedA', 'aMultiDerivedBoolean'] ));
  assert( BoldMembers[28] is TBABoolean, format( BoldMemberAssertInvalidType, [ClassName, 'aMultiDerivedBoolean', 'TBABoolean'] ));
  assert( BoldMembers[28].BoldMemberRTInfo.DelphiName = 'aMultiDerivedBoolean', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aMultiDerivedBoolean', BoldMembers[28].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[28] as TBABoolean;
end;

function TClassMultiDerivedA._GetaMultiDerivedBoolean: Boolean;
begin
  Result := M_aMultiDerivedBoolean.AsBoolean;
end;


function TClassMultiDerivedA._Get_M_aMultiDerivedByte: TBAByte;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassMultiDerivedA', 'aMultiDerivedByte'] ));
  assert( BoldMembers[29] is TBAByte, format( BoldMemberAssertInvalidType, [ClassName, 'aMultiDerivedByte', 'TBAByte'] ));
  assert( BoldMembers[29].BoldMemberRTInfo.DelphiName = 'aMultiDerivedByte', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aMultiDerivedByte', BoldMembers[29].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[29] as TBAByte;
end;

function TClassMultiDerivedA._GetaMultiDerivedByte: Byte;
begin
  Result := M_aMultiDerivedByte.AsByte;
end;


function TClassMultiDerivedA._Get_M_aMultiDerivedCurrency: TBACurrency;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassMultiDerivedA', 'aMultiDerivedCurrency'] ));
  assert( BoldMembers[30] is TBACurrency, format( BoldMemberAssertInvalidType, [ClassName, 'aMultiDerivedCurrency', 'TBACurrency'] ));
  assert( BoldMembers[30].BoldMemberRTInfo.DelphiName = 'aMultiDerivedCurrency', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aMultiDerivedCurrency', BoldMembers[30].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[30] as TBACurrency;
end;

function TClassMultiDerivedA._GetaMultiDerivedCurrency: Currency;
begin
  Result := M_aMultiDerivedCurrency.AsCurrency;
end;


function TClassMultiDerivedA._Get_M_aMultiDerivedDate: TBADate;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassMultiDerivedA', 'aMultiDerivedDate'] ));
  assert( BoldMembers[31] is TBADate, format( BoldMemberAssertInvalidType, [ClassName, 'aMultiDerivedDate', 'TBADate'] ));
  assert( BoldMembers[31].BoldMemberRTInfo.DelphiName = 'aMultiDerivedDate', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aMultiDerivedDate', BoldMembers[31].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[31] as TBADate;
end;

function TClassMultiDerivedA._GetaMultiDerivedDate: TDate;
begin
  Result := M_aMultiDerivedDate.AsDate;
end;


function TClassMultiDerivedA._Get_M_aMultiDerivedDateTime: TBADateTime;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassMultiDerivedA', 'aMultiDerivedDateTime'] ));
  assert( BoldMembers[32] is TBADateTime, format( BoldMemberAssertInvalidType, [ClassName, 'aMultiDerivedDateTime', 'TBADateTime'] ));
  assert( BoldMembers[32].BoldMemberRTInfo.DelphiName = 'aMultiDerivedDateTime', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aMultiDerivedDateTime', BoldMembers[32].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[32] as TBADateTime;
end;

function TClassMultiDerivedA._GetaMultiDerivedDateTime: TDateTime;
begin
  Result := M_aMultiDerivedDateTime.AsDateTime;
end;


function TClassMultiDerivedA._Get_M_aMultiDerivedFloat: TBAFloat;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassMultiDerivedA', 'aMultiDerivedFloat'] ));
  assert( BoldMembers[33] is TBAFloat, format( BoldMemberAssertInvalidType, [ClassName, 'aMultiDerivedFloat', 'TBAFloat'] ));
  assert( BoldMembers[33].BoldMemberRTInfo.DelphiName = 'aMultiDerivedFloat', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aMultiDerivedFloat', BoldMembers[33].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[33] as TBAFloat;
end;

function TClassMultiDerivedA._GetaMultiDerivedFloat: double;
begin
  Result := M_aMultiDerivedFloat.AsFloat;
end;


function TClassMultiDerivedA._Get_M_aMultiDerivedInteger: TBAInteger;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassMultiDerivedA', 'aMultiDerivedInteger'] ));
  assert( BoldMembers[34] is TBAInteger, format( BoldMemberAssertInvalidType, [ClassName, 'aMultiDerivedInteger', 'TBAInteger'] ));
  assert( BoldMembers[34].BoldMemberRTInfo.DelphiName = 'aMultiDerivedInteger', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aMultiDerivedInteger', BoldMembers[34].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[34] as TBAInteger;
end;

function TClassMultiDerivedA._GetaMultiDerivedInteger: Integer;
begin
  Result := M_aMultiDerivedInteger.AsInteger;
end;


function TClassMultiDerivedA._Get_M_aMultiDerivedShortInt: TBAShortInt;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassMultiDerivedA', 'aMultiDerivedShortInt'] ));
  assert( BoldMembers[35] is TBAShortInt, format( BoldMemberAssertInvalidType, [ClassName, 'aMultiDerivedShortInt', 'TBAShortInt'] ));
  assert( BoldMembers[35].BoldMemberRTInfo.DelphiName = 'aMultiDerivedShortInt', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aMultiDerivedShortInt', BoldMembers[35].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[35] as TBAShortInt;
end;

function TClassMultiDerivedA._GetaMultiDerivedShortInt: ShortInt;
begin
  Result := M_aMultiDerivedShortInt.AsShortInt;
end;


function TClassMultiDerivedA._Get_M_aMultiDerivedSmallInt: TBASmallInt;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassMultiDerivedA', 'aMultiDerivedSmallInt'] ));
  assert( BoldMembers[36] is TBASmallInt, format( BoldMemberAssertInvalidType, [ClassName, 'aMultiDerivedSmallInt', 'TBASmallInt'] ));
  assert( BoldMembers[36].BoldMemberRTInfo.DelphiName = 'aMultiDerivedSmallInt', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aMultiDerivedSmallInt', BoldMembers[36].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[36] as TBASmallInt;
end;

function TClassMultiDerivedA._GetaMultiDerivedSmallInt: SmallInt;
begin
  Result := M_aMultiDerivedSmallInt.AsSmallInt;
end;


function TClassMultiDerivedA._Get_M_aMultiDerivedTime: TBATime;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassMultiDerivedA', 'aMultiDerivedTime'] ));
  assert( BoldMembers[37] is TBATime, format( BoldMemberAssertInvalidType, [ClassName, 'aMultiDerivedTime', 'TBATime'] ));
  assert( BoldMembers[37].BoldMemberRTInfo.DelphiName = 'aMultiDerivedTime', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aMultiDerivedTime', BoldMembers[37].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[37] as TBATime;
end;

function TClassMultiDerivedA._GetaMultiDerivedTime: TTime;
begin
  Result := M_aMultiDerivedTime.AsTime;
end;


function TClassMultiDerivedA._Get_M_aMultiDerivedString: TBAString;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassMultiDerivedA', 'aMultiDerivedString'] ));
  assert( BoldMembers[38] is TBAString, format( BoldMemberAssertInvalidType, [ClassName, 'aMultiDerivedString', 'TBAString'] ));
  assert( BoldMembers[38].BoldMemberRTInfo.DelphiName = 'aMultiDerivedString', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aMultiDerivedString', BoldMembers[38].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[38] as TBAString;
end;

function TClassMultiDerivedA._GetaMultiDerivedString: String;
begin
  Result := M_aMultiDerivedString.AsString;
end;


function TClassMultiDerivedA._Get_M_aMultiDerivedWord: TBAWord;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClassMultiDerivedA', 'aMultiDerivedWord'] ));
  assert( BoldMembers[39] is TBAWord, format( BoldMemberAssertInvalidType, [ClassName, 'aMultiDerivedWord', 'TBAWord'] ));
  assert( BoldMembers[39].BoldMemberRTInfo.DelphiName = 'aMultiDerivedWord', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aMultiDerivedWord', BoldMembers[39].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[39] as TBAWord;
end;

function TClassMultiDerivedA._GetaMultiDerivedWord: Word;
begin
  Result := M_aMultiDerivedWord.AsWord;
end;



procedure TClassMultiDerivedAList.Add(NewObject: TClassMultiDerivedA);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TClassMultiDerivedAList.IndexOf(anObject: TClassMultiDerivedA): Integer;
begin
  result := IndexOfElement( anObject );
end;

function TClassMultiDerivedAList.Includes( anObject: TClassMultiDerivedA ) : Boolean;
begin
  result := IncludesElement( anObject );
end;

procedure TClassMultiDerivedAList.Insert(index: Integer; NewObject: TClassMultiDerivedA);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TClassMultiDerivedAList.GetBoldObject(index: Integer): TClassMultiDerivedA;
begin
  result := GetElement(index) as TClassMultiDerivedA;
end;

procedure TClassMultiDerivedAList.SetBoldObject(index: Integer; NewObject: TClassMultiDerivedA);
begin;
  SetElement( index, NewObject );
end;



function GeneratedCodeCRC: integer;
begin
  result := 0;
end;

procedure InstallObjectListClasses(BoldObjectListClasses: TBoldGeneratedClassList);
begin
  BoldObjectListClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRootList);
  BoldObjectListClasses.AddObjectEntry('ClassA', TClassAList);
  BoldObjectListClasses.AddObjectEntry('ClassB', TClassBList);
  BoldObjectListClasses.AddObjectEntry('ClassDerivedA', TClassDerivedAList);
  BoldObjectListClasses.AddObjectEntry('ClassOclDerivedA', TClassOclDerivedAList);
  BoldObjectListClasses.AddObjectEntry('ClassMultiDerivedA', TClassMultiDerivedAList);
end;

procedure InstallBusinessClasses(BoldObjectClasses: TBoldGeneratedClassList);
begin
  BoldObjectClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRoot);
  BoldObjectClasses.AddObjectEntry('ClassA', TClassA);
  BoldObjectClasses.AddObjectEntry('ClassB', TClassB);
  BoldObjectClasses.AddObjectEntry('ClassDerivedA', TClassDerivedA);
  BoldObjectClasses.AddObjectEntry('ClassOclDerivedA', TClassOclDerivedA);
  BoldObjectClasses.AddObjectEntry('ClassMultiDerivedA', TClassMultiDerivedA);
end;

var
  CodeDescriptor: TBoldGeneratedCodeDescriptor;

initialization
  CodeDescriptor := GeneratedCodes.AddGeneratedCodeDescriptorWithFunc( 'jehoBCBoldTest', InstallBusinessClasses, InstallObjectListClasses );
finalization
  GeneratedCodes.Remove(CodeDescriptor);
end.



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
