(************************************)
(*    This file is autogenerated    *)
(* Any manual changes will be LOST! *)
(************************************)

(* This file should be stored in the same directory    *)
(* as the form/datamodule with the corresponding model *)

// 

{ File generated  }

unit NullableMomentAttributes;

{$DEFINE NullableMomentAttributes_unitheader}
{$INCLUDE NullableMomentAttributes_Interface.inc}

uses
  {ImplementationUses}
  {ImplementationDependancies}
  BoldSystemRT,
  BoldGeneratedCodeDictionary;

{ Includefile for methodimplementations }

{$INCLUDE NullableMomentAttributes.inc}

const
  BoldMemberAssertSelfAssigned: string = 'Unable to access member %s.%s: Object is not assigned!)';
  BoldMemberAssertInvalidType: string = 'Invalid membertype for %s.%s. Expected %s (code might be out of sync with model)';
  BoldMemberAssertInvalidObjectType: string = 'Object of singlelink (%s.%s) is of wrong type (is %s, should be %s)';
  BoldMemberAssertInvalidDelphiName: string = '%s.%s: Member is incorrect. it is called %s in meta info (code might be out of sync with model)';

{ TBusinessClassesRoot }


procedure TBusinessClassesRootList.Add(NewObject: TBusinessClassesRoot);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TBusinessClassesRootList.IndexOf(anObject: TBusinessClassesRoot): Integer;
begin
  result := IndexOfElement( anObject );
end;

function TBusinessClassesRootList.Includes( anObject: TBusinessClassesRoot ) : Boolean;
begin
  result := IncludesElement( anObject );
end;

procedure TBusinessClassesRootList.Insert(index: Integer; NewObject: TBusinessClassesRoot);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TBusinessClassesRootList.GetBoldObject(index: Integer): TBusinessClassesRoot;
begin
  result := GetElement(index) as TBusinessClassesRoot;
end;

procedure TBusinessClassesRootList.SetBoldObject(index: Integer; NewObject: TBusinessClassesRoot);
begin;
  SetElement( index, NewObject );
end;


{ TClasswithDates }

function TClasswithDates._Get_M_aDate: TBADate;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClasswithDates', 'aDate'] ));
  assert( BoldMembers[0] is TBADate, format( BoldMemberAssertInvalidType, [ClassName, 'aDate', 'TBADate'] ));
  assert( BoldMembers[0].BoldMemberRTInfo.DelphiName = 'aDate', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aDate', BoldMembers[0].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[0] as TBADate;
end;

function TClasswithDates._GetaDate: TDate;
begin
  Result := M_aDate.AsDate;
end;

procedure TClasswithDates._SetaDate(NewValue: TDate);
begin
  M_aDate.AsDate := NewValue;
end;

function TClasswithDates._Get_M_aNullableDate: TBADate;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClasswithDates', 'aNullableDate'] ));
  assert( BoldMembers[1] is TBADate, format( BoldMemberAssertInvalidType, [ClassName, 'aNullableDate', 'TBADate'] ));
  assert( BoldMembers[1].BoldMemberRTInfo.DelphiName = 'aNullableDate', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aNullableDate', BoldMembers[1].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[1] as TBADate;
end;

function TClasswithDates._GetaNullableDate: TDate;
begin
  Result := M_aNullableDate.AsDate;
end;

procedure TClasswithDates._SetaNullableDate(NewValue: TDate);
begin
  M_aNullableDate.AsDate := NewValue;
end;

function TClasswithDates._Get_M_aTime: TBATime;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClasswithDates', 'aTime'] ));
  assert( BoldMembers[2] is TBATime, format( BoldMemberAssertInvalidType, [ClassName, 'aTime', 'TBATime'] ));
  assert( BoldMembers[2].BoldMemberRTInfo.DelphiName = 'aTime', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aTime', BoldMembers[2].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[2] as TBATime;
end;

function TClasswithDates._GetaTime: TTime;
begin
  Result := M_aTime.AsTime;
end;

procedure TClasswithDates._SetaTime(NewValue: TTime);
begin
  M_aTime.AsTime := NewValue;
end;

function TClasswithDates._Get_M_aNullableTime: TBATime;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClasswithDates', 'aNullableTime'] ));
  assert( BoldMembers[3] is TBATime, format( BoldMemberAssertInvalidType, [ClassName, 'aNullableTime', 'TBATime'] ));
  assert( BoldMembers[3].BoldMemberRTInfo.DelphiName = 'aNullableTime', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aNullableTime', BoldMembers[3].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[3] as TBATime;
end;

function TClasswithDates._GetaNullableTime: TTime;
begin
  Result := M_aNullableTime.AsTime;
end;

procedure TClasswithDates._SetaNullableTime(NewValue: TTime);
begin
  M_aNullableTime.AsTime := NewValue;
end;

function TClasswithDates._Get_M_aDateTime: TBADateTime;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClasswithDates', 'aDateTime'] ));
  assert( BoldMembers[4] is TBADateTime, format( BoldMemberAssertInvalidType, [ClassName, 'aDateTime', 'TBADateTime'] ));
  assert( BoldMembers[4].BoldMemberRTInfo.DelphiName = 'aDateTime', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aDateTime', BoldMembers[4].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[4] as TBADateTime;
end;

function TClasswithDates._GetaDateTime: TDateTime;
begin
  Result := M_aDateTime.AsDateTime;
end;

procedure TClasswithDates._SetaDateTime(NewValue: TDateTime);
begin
  M_aDateTime.AsDateTime := NewValue;
end;

function TClasswithDates._Get_M_aNullableDateTime: TBADateTime;
begin
  assert( assigned( self ), format( BoldMemberAssertSelfAssigned, ['TClasswithDates', 'aNullableDateTime'] ));
  assert( BoldMembers[5] is TBADateTime, format( BoldMemberAssertInvalidType, [ClassName, 'aNullableDateTime', 'TBADateTime'] ));
  assert( BoldMembers[5].BoldMemberRTInfo.DelphiName = 'aNullableDateTime', format( BoldMemberAssertInvalidDelphiName, [ClassName, 'aNullableDateTime', BoldMembers[5].BoldMemberRTInfo.DelphiName] ));
  Result := BoldMembers[5] as TBADateTime;
end;

function TClasswithDates._GetaNullableDateTime: TDateTime;
begin
  Result := M_aNullableDateTime.AsDateTime;
end;

procedure TClasswithDates._SetaNullableDateTime(NewValue: TDateTime);
begin
  M_aNullableDateTime.AsDateTime := NewValue;
end;


procedure TClasswithDatesList.Add(NewObject: TClasswithDates);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TClasswithDatesList.IndexOf(anObject: TClasswithDates): Integer;
begin
  result := IndexOfElement( anObject );
end;

function TClasswithDatesList.Includes( anObject: TClasswithDates ) : Boolean;
begin
  result := IncludesElement( anObject );
end;

procedure TClasswithDatesList.Insert(index: Integer; NewObject: TClasswithDates);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TClasswithDatesList.GetBoldObject(index: Integer): TClasswithDates;
begin
  result := GetElement(index) as TClasswithDates;
end;

procedure TClasswithDatesList.SetBoldObject(index: Integer; NewObject: TClasswithDates);
begin;
  SetElement( index, NewObject );
end;



function GeneratedCodeCRC: integer;
begin
  result := 0;
end;

procedure InstallObjectListClasses(BoldObjectListClasses: TBoldGeneratedClassList);
begin
  BoldObjectListClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRootList);
  BoldObjectListClasses.AddObjectEntry('ClasswithDates', TClasswithDatesList);
end;

procedure InstallBusinessClasses(BoldObjectClasses: TBoldGeneratedClassList);
begin
  BoldObjectClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRoot);
  BoldObjectClasses.AddObjectEntry('ClasswithDates', TClasswithDates);
end;

var
  CodeDescriptor: TBoldGeneratedCodeDescriptor;

initialization
  CodeDescriptor := GeneratedCodes.AddGeneratedCodeDescriptorWithFunc( 'NullableMomentAttributes', InstallBusinessClasses, InstallObjectListClasses );
finalization
  GeneratedCodes.Remove(CodeDescriptor);
end.



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
