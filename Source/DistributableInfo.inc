    {**********************************************************}
    {                                                          }
    {       Bold for Delphi Stub File                          }
    {                                                          }
    {       Autogenerated file for method implementations      }
    {                                                          }
    {**********************************************************}

{$INCLUDE DistributableInfo_Interface.inc}

procedure TCheckingInObjectInfo.AcknowledgeCheckIn(NewTimeStamp: Integer);
var
  aHeldObjectInfo: THeldObjectInfo;
begin
  if HeldObjectInfo.ForeignObjectInfo.ForeignTimeStamp <= NewTimeStamp then
    HeldObjectInfo.ForeignObjectInfo.ForeignTimeStamp := NewTimeStamp
  else
    raise EBold.CreateFmt('%s.AcknowledgeCheckIn: New timestamp is older than current', [classname]);
  if KeepHold then
    HeldObjectInfo.OriginalLocalTimeStamp := LocalTimeStampAtCheckIn
  else
  begin
    aHeldObjectInfo := HeldObjectInfo;
    aHeldObjectInfo.UnLinkAll;
    aHeldObjectInfo.Delete;
  end;
  self.UnLinkAll;
  self.Delete;
end;


procedure TCheckingInObjectInfo.FailCheckIn;
begin
  self.UnLinkAll;
  self.Delete;
end;


procedure TForeignObjectInfo.StartCheckIn(ValueSpace: IBoldValueSpace; KeepHold: Boolean);
begin
  if not assigned(HeldObjectInfo) then
    raise EBold.CreateFmt('%s.StartCheckIn: Object is not held', [Classname]);

  HeldObjectInfo.StartCheckIn(ValueSpace, KeepHold);
end;


procedure THeldObjectInfo.StartCheckIn(ValueSpace: IBoldValueSpace; KeepHold: Boolean);
var
  anId: TBoldDefaultId;
begin
  if assigned(CheckingInObjectInfo) then
    raise EBold.CreateFmt('%s.StartCheckIn: Object already checking in', [Classname]);

  anId := TBoldDefaultId.Create;
  try
    CheckingInObjectInfo := TCheckingInObjectInfo.Create(self.BoldSystem);
    CheckingInObjectInfo.KeepHold := KeepHold;
    anId.AsInteger := ForeignObjectInfo.LocalId;
    CheckingInObjectInfo.LocalTimeStampAtCheckIn := ValueSpace.ObjectContentsByObjectId[anId].TimeStamp;
    ValueSpace.ObjectContentsByObjectId[anId].TimeStamp := ForeignObjectInfo.ForeignTimeStamp;
  finally
    anId.Free;
  end;
end;


procedure TOwnObjectInfo.StartCheckIn(ValueSpace: IBoldValueSpace; KeepHold: Boolean);
begin
  raise EBold.CreateFmt('%s.StartCheckIn: Object is own object', [Classname]);
end;

procedure TForeignObjectInfo.InitializeHolding(ObjectId: TBoldObjectId; Owner: TForeignPSInfo);
begin
  HeldObjectInfo := THeldObjectInfo.Create(BoldSystem);
  LocalId := (ObjectId as TBoldDefaultId).AsInteger;
  ForeignTimeStamp := 0;
  self.Owner := Owner;
  HeldObjectInfo.OriginalLocalTimeStamp := 0;
end;


procedure TForeignObjectInfo.Put(ValueSpace: IBoldValueSpace; Hold: Boolean; NewLocalTimeStamp: Integer);
var
  NewTimeStamp: Integer;
  anObjectId: TBoldDefaultId;
begin
  anObjectId := TBoldDefaultId.Create;
  try
    anObjectId.AsInteger := LocalId;
    NewTimeStamp := ValueSpace.ObjectContentsByObjectId[anObjectId].TimeStamp;
    if NewTimeStamp < ForeignTimeStamp then
      raise EBold.CreateFmt('%s.EnsureForeignInfo: New timestamp is older than current', [Classname]);
    ForeignTimeStamp := NewTimeStamp;
    if Hold then
      self.Hold(NewLocalTimeStamp);
  finally
    anObjectId.Free;
  end;
end;


procedure TForeignObjectInfo.Hold(NewLocalTimeStamp: Integer);
begin
  HeldObjectInfo := THeldObjectInfo.Create(BoldSystem);
  HeldObjectInfo.OriginalLocalTimeStamp := NewLocalTimeStamp;
end;


procedure TForeignObjectInfo.Get(ValueSpace: IBoldValueSpace; CheckOut: Boolean; Holder: TForeignPSInfo);
begin
  raise EBold.CreateFmt('%s.Get: Object is a Foreign object', [Classname]);
end;


procedure TOwnObjectInfo.Get(ValueSpace: IBoldValueSpace; CheckOut: Boolean; Holder: TForeignPSInfo);
begin
  if CheckOut then
    self.CheckOut(Holder);
end;

procedure TOwnObjectInfo.CheckOut(Holder: TForeignPSInfo);
begin
  if assigned(CheckedOutObjectInfo) then
    raise EBold.CreateFmt('%s.CheckOut: Object is already checked out', [Classname]);
  CheckedOutObjectInfo := TCheckedOutObjectInfo.Create(BoldSystem);
  CheckedOutObjectInfo.Holder := Holder;
end;

procedure TOwnObjectInfo.CheckIn(ValueSpace: IBoldValueSpace; Release: Boolean; Holder: TForeignPSInfo);
begin
  if not assigned(CheckedOutObjectInfo) then
    raise EBold.CreateFmt('%s.CheckIn: Object not checked out', [Classname]);
  if not (CheckedOutObjectInfo.Holder = Holder) then
    raise EBold.CreateFmt('%s.CheckIn: Object checked out to another holder', [Classname]);
  if Release then
    CheckedOutObjectInfo.Delete;
end;


procedure TForeignPSInfo.AcknowledgeCheckIn(NewTimeStamp: Integer);
var
  anElement: TBoldIndirectElement;
  InfoObjects: TBoldObjectList;
  i: Integer;
begin
  anElement := TBoldIndirectElement.Create;
  try
    EvaluateExpression('ownedObjectInfos.heldObjectInfo.checkingInObjectInfo', anElement);
    InfoObjects := anElement.Value as TBoldObjectList;
    for i := InfoObjects.Count-1 downto 0 do
      (InfoObjects[i] as TCheckingInObjectInfo).AcknowledgeCheckIn(NewTimeStamp);
  finally
    anElement.Free;
  end;
end;                      


procedure TForeignPSInfo.FailCheckIn(FailedReleaseList: TBoldObjectIdList);
var
  anElement: TBoldIndirectElement;
  InfoObjects: TBoldObjectList;
  i: Integer;
  anId: TBoldDefaultId;
  aCIInfo: TCheckingInObjectInfo;
begin
  anId := TBoldDefaultId.CreateWithClassId(BUSINESSCLASSESROOT_TOPSORTEDINDEX, false);
  anElement := TBoldIndirectElement.Create;
  try
    EvaluateExpression('ownedObjectInfos.heldObjectInfo.checkingInObjectInfo', anElement);
    InfoObjects := anElement.Value as TBoldObjectList;
    for i := 0 to InfoObjects.Count-1 do
    begin
      aCIInfo := InfoObjects[i] as TCheckingInObjectInfo;
      if not aCIInfo.KeepHold then
      begin
        anId.AsInteger := aCIInfo.HeldObjectInfo.ForeignObjectInfo.LocalId;
        FailedReleaseList.Add(anId);
      end;
      aCIInfo.FailCheckIn;
    end;
  finally
    anId.Free;
    anElement.Free;
  end;
end;

function TForeignPSInfo.IsCheckingIn: Boolean;
var
  anElement: TBoldIndirectElement;
begin
  anElement := TBoldIndirectElement.Create;
  try
    EvaluateExpression('ownedObjectInfos.heldObjectInfo.checkingInObjectInfo->size', anElement);
    result := (anElement.Value as TBAInteger).AsInteger > 0;
  finally
    anElement.Free;
  end;
end;

procedure TOwnObjectInfo.UnCheckOut(Holder: TForeignPSInfo);
begin
end;

function TForeignPSInfo.IsSynching: Boolean;
begin
  result := OngoingSynchTimestamp <> -1;
end;

